# Effective Java

### :paperclip: Contents

2. [객체 생성과 파괴](#2장-객체-생성과-파괴)
3. [모든 객체의 공통 메서드](#3장-모든-객체의-공통-메서드)
4. [클래스와 인터페이스](#4장-클래스와-인터페이스)
5. [제네릭](#5장-제네릭)
6. [열거 타입과 애너테이션](#6장-열거-타입과-애너테이션)
7. [람다와 스트림](#7장-람다와-스트림)
8. [메서드](#8장-메서드)
9. [일반적인 프로그래밍 원칙](#9장-일반적인-프로그래밍-원칙)
10. [예외](#10장-예외)
11. [동시성](#11장-동시성)
12. [직렬화](#12장-직렬화)

---

## 2장 객체 생성과 파괴

### Item 1 - "생성자 대신 정적 팩토리 메서드를 고려하라"

**Static Factory Method**
생성자와는 별도로 해당 클래스의 인스턴스를 반환  
ex)
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

- 정적 팩토리 메서드가 생성자 보다 좋은 점
    1. **이름을 가질 수 있다.**
        - 반환될 객체의 특성을 쉽게 묘사할 수 있다.
        - ex) 
            ```java
            BigInteger.probablePrime  // 값이 소수인 BigInteger 반환
            ```
    2. **호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.**
        - 인스턴스를 미리 생성, 재활용 함으로 불필요한 객체 생성 방지
    3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**
        - 인터페이스 구현 클래스의 인스턴스를 public으로 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지 가능
        - 클라이언트가 API를 사용하기 위해 익혀야 하는 개념적인 무게도 낮춤
        - 인터페이스 기반 프레임워크를 만드는 핵심 기술
        - ex) `java.util.Collections`
        - 팩토리를 사용하는 코드가 구현체가 아닌 인터페이스 타입으로 코딩 가능
        > - **Java 8** 부터 인터페이스는 **public static method** 를 가질 수 있다.  
        > - **Java 9** 부터는 **private static method** 가능 But, 정적 필드와 정적 멤버 클래스는 여전히 public
    4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
        - 3번의 연장선
        - 클라이언트는 팩토리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수 없고 알 필요도 없음
        - JDK의 변화나 릴리즈가 달라져 새로운 타입을 만들거나 없애도 문제가 되지 않음
        - ex) `EnumSet`클래스는 public 생성자 없이 정적 팩토리만 제공. 원소의 수에 따라 `RegularEnumSet` 또는 `JumboEnumSet` 인스턴스 반환
    5. **정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**
        - 3번 부터 연장되는 '유연함'에 대한 설명
        - **Service Provider Framework** 을 만드는 근간
        - 제공자는 서비스의 구현체. 이 구현체들을 클라이언트에 제공하는 역할을 프레임웍이 통제하여, 클라이언트를 구현체로부터 분리
        - 서비스 제공자 프레임 워크의 핵심 컴포넌트:

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 3장 모든 객체의 공통 메서드

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 4장 클래스와 인터페이스

### item 15 - "클래스와 멤버의 접근 권한을 최소화하라"

- 잘 설계된 컴포넌트의 특징: **정보은닉 & 캡슐화**
    - 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트부터 잘 숨김
    - API를 통해서만 다른 컴포넌트와 소통. 내부 동작 방식에 개의치 않음.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
    - 꼭 필요한 최소한의 공개 API만 public으로 선언
    - protected 멤버는 공개 API 임
    - 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안된다.
    - 가변적인 public 인스턴스는 일반적으로 thread-safe 하지 않다.
        - 예외: 상수(public static final) - 반드시 기본 타입이나 불변 객체 참조
            > ex) public static final 배열은 변경 가능하므로 주의
- 정보 은닉의 장점:
    1. 시스템 개발 속도를 높인다
    2. 시스템 관리 비용을 낮춘다.
    3. 성능 최적화에 도움
    4. 소프트웨어 재사용성을 높인다.
    5. 큰 시스템을 제작하는 난이도를 낮춘다.

<br/>

### item 16 - "public 클래스에서는 public 필드가 아닌 접근자 메소드를 사용하라"

- 데이터 필드에 대한 직접 접근의 문제점
    - 캡슐화의 이점을 제공받지 못함
    - API를 수정하지 않고 내부 표현을 바꿀 수 없음
    - 불변식 보장 불가
    - 외부에서 필드에 접근할 떄 부수 작업 수행 불가
- private 필드와 접근자(getter) 사용
    - 가변 필드의 직접 노출 금지
    - 클래스 내부 데이터 표현 방식 변경의 유연성 획득
- package-private 클래스 혹은 private 중첩 클래스에 대해선 예외
    - 해당 클래스가 표현하려는 추상 개념만 올바르게 표현

<br>

### item 17 - "변경 가능성을 최소화하라"

    불변 클래스: 그 인스턴스의 내부 값을 수정할 수 없는 클래스

- 클래스를 불변으로 설계하는 이유:
    - 설계하고 구현하기 쉬움
    - 오류가 생길 여지가 적고 안전함
    - ex) String, 기본 타입이 박싱된 클래스, BigInteger, BigDecimal 등
- 클래스를 불변으로 만드는 5가지 규칙
    1. 객체의 상태를 변경하는 메소드(변경자)를 제공하지 않는다.
    2. 클래스를 확장할 수 없도록 한다.
        - 간단한 방법: final 클래스로 선언
        - 유연한 방법: **모든 생성자를 private 또는 package-private으로 만들고 public 정적 팩토리 제공**
    3. 모든 필드를 final로 선언한다.
    4. 모든 필드를 private으로 선언한다.
    5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
- 불변 객체의 특징 및 장점
    - 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직
    - thread-safe 하여 따로 동기화할 필요 없음
        > 한번 만든 인스턴스를 공유 및 재활용
    - 정적 팩토리 제공 가능
        > 인스턴스 중복 생성을 방지 및 재활용하여 메모리 사용량과 GC 비용이 줄어듬
    - 방어적 복사(clone)가 필요 없음
    - 불변 객체끼리 내부 데이터 공유 가능
    - 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 그 구조가 복잡하더라도 불변식을 유지하기 수월
    - 실패 원자성 제공
        > 메소드에서 예외가 발생하더라도 그 객체는 여전히 이전과 같이 유효한 상태
- 불변 객체의 단점:
    - 값이 다르다면 반드시 독립된 객체로 만들어야 함

- 정리
    - **클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.**
    - 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
    - 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.

<br>

### item 18 - "상속보다는 컴포지션을 사용하라"

- 상속이 안전한 경우
    - 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서의 상속
    - 확장할 목적으로 설계되었고 문서화도 잘 된 클래스

- 상속이 안전하지 않은 경우
    - 다른 패키지의 구체 클래스를 상속
    - 즉, 인터페이스 상속이 아닌 클래스가 다른 클래스를 확장하는 구현 상속
        > *이 책에서 말하는 상속*

- 상속의 문제점
    - 메소드 호출과 달리 상속은 캡슐화를 깨뜨린다.
        > 클래스 확장을 고려한다면 문서화 필요
        
        - 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
            1. **자기사용이 존재하는 메소드의 재정의**
                - **'자기사용(self-use)':** 상위 클래스에서 자신의 다른 부분을 사용
                - 자기사용이 있는 메소드를 재정의할 때 의도치 않은 결과가 나타날 수 있다.
                - 자기사용 여부를 알 수 없고 또한 다음 릴리즈에 유지될지도 알 수 없다.
            2. **상위 클래스의 메소드 추가**
                - 하위 클래스에 추가한 메소드와 시그니처가 같고 반환 타입이 다르다면 컴파일조차 불가
                - 하위 클래스에서 메소드를 작성할 때 상위 클래스의 메소드는 존재하지 않아, 상위 클래스의 메소드가 요구하는 규약을 만족하지 못할 가능성이 큼

- 상속의 문제 해결: **Composition(구성)**
    - 방법: 
        - 클래스를 확장하는 대신, private 필드로 기존 클래스의 인스턴스를 참조
    - **전달**(forwarding): 기존 클래스의 메소드를 호출하여 결과 반환
    - **전달 메소드**(forwarding method): 기존 클래스의 메소드를 사용하는 메소드
    - **래퍼 클래스**: 다른 인스턴스를 감싸고 있는 클래스 / *데코레이터 패턴*
    - **위임**(delegation): 컴포지션과 전달의 조합. 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우

- 래퍼 클래스의 단점
    - 래퍼 클래스는 콜백 프레임워크와는 어울리지 않음  
    - **콜백 프레임워크**: 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출(콜백) 때 사용  
    - **SELF 문제**: 내부 객체는 자신을 감싸고 있는 래퍼의 존재를  모르니 대신 자신의 참조를 넘기고, 콜백 때는 래퍼가 아닌 내부 객체를 호출
    - 해결 방법: **전달 클래스** (전달 메소드) 작성 필요
        - 원하는 기능을 덧씌우는 작업 (인터페이스당 하나씩)
        - 재사용 가능

- 상속에 대한 주의점
    - 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 함
        > is-a 관계일 때만
    - 컴포지션을 써야 할 상황에서 상속은 사용하는 건 내부 구현을 불필요하게 노출하는 꼴
        - API가 내부 구현에 묶이고 그 클래스의 성능도 제한됨
        - 클라이언트가 노출된 내부에 직접 접근 가능
        - 클라이언트에서 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 해칠 수 있다.

<br>

### item 19 - "상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라"

- **상속용 클래스는 재정의 할 수 있는 메소드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.**
    - 내용:
        - 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지
        - 재정의 가능 메소드를 호출할 수 있는 모든 상황 (ex. 백그라운드 스레드나 정적 초기화 과정에서의 호출)
    - API 문서의 "Implementation Requirements": 해당 메소드의 내부 동작 방식 설명
        - 메소드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해 줌
        - 좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다.
    - 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야한다.
        > "좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다"와는 대치

- **클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메소드 형태로 공개해야 할 수도 있다.**
    - ex) java.util.AbstractList의 removeRange: 최종 구현자는 해당 메소드에 관심이 없지만 이 메소드를 사용하는 clear 메소드를 고성능으로 만들기 쉽게 한다.

- **상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일**
    - 상속용으로 설계한 클래스는 배포 전 반드시 하위 클래스를 만들어 검증
        > 보통 3개 정도. 이 중 하나 이상은 제3자가 작성 필요

- **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안된다.**    
    - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행
    - 하위 클래스에서 재정의한 메소드가 하위 클래스의 생성자보다 먼저 실행
    - 재정의한 메소드가 하위 클래스의 생성자에서 초기화 하는 값에 의존하면 오동작 가능성
        > private, final, static 메소드는 재정의가 불가능하니 호출해도 무관

- **Cloneable과 Serializable 인터페이스를 구현한 클래스를 상속할 수 있게 하는 것은 좋지 않은 생각.**
    - 그럼에도 상속을 할 수 있게 하는 방법:
        - clone과 readObject 모두 직간접적으로 재정의 가능 메소드를 호출해서는 안 된다.
        - Serializeable을 구현한 상속용 클래스가 readResolve나 writeReplace 메소드를 갖는다면 private이 아닌 protected로 선언해야 한다.

- 상속에 대한 문제점 해결 방법
    - **상속용으로 설계하지 않은 클래스는 상속을 금지하자.** ([item 17](#item-17---"변경-가능성을-최소화하라"))
        - 방법 1: 클래스를 final로 선언
        - 방법 2: 모든 생성자를 private이나 package-private으로 선언, public 정적 팩토리 제공
    - 인터페이스를 구현한 클래스의 상속 허용 - **래퍼 클래스 패턴** ([item 18](#item-18---"상속보다는-컴포지션을-사용하라"))
    - 인터페이스를 구현하지 않은 구체 클래스의 상속 허용
        - 클래스 내부에서는 재정의 가능 메소드를 사용하지 않게 만들고 문서화로 남김
            > 재정의 가능 메소드를 호출하는 자기 사용 코드를 제거
        - 클래스의 동작을 유지하며 재정의 가능 메소드를 사용하는 코드를 제거하는 방법
            - 재정의 가능 메소드는 자신의 본문 코드를 private '도우미 메소드'로 옮기고, 도우미 메소드를 호출하도록 수정
            - 재정의 가능 메소드를 호출하는 모든 코드들도 도우미 메소드를 호출하도록 수정

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 5장 제네릭

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 6장 열거 타입과 애너테이션

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 7장 람다와 스트림

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 8장 메서드

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 9장 일반적인 프로그래밍 원칙

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 10장 예외

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 11장 동시성

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 12장 직렬화

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>
