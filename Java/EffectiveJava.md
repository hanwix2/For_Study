# Effective Java

### :paperclip: Contents

2. [객체 생성과 파괴](#2장-객체-생성과-파괴)
3. [모든 객체의 공통 메서드](#3장-모든-객체의-공통-메서드)
4. [클래스와 인터페이스](#4장-클래스와-인터페이스)
5. [제네릭](#5장-제네릭)
6. [열거 타입과 애너테이션](#6장-열거-타입과-애너테이션)
7. [람다와 스트림](#7장-람다와-스트림)
8. [메서드](#8장-메서드)
9. [일반적인 프로그래밍 원칙](#9장-일반적인-프로그래밍-원칙)
10. [예외](#10장-예외)
11. [동시성](#11장-동시성)
12. [직렬화](#12장-직렬화)

---

## 2장 객체 생성과 파괴

### :label: Item 1 - "생성자 대신 정적 팩토리 메서드를 고려하라"

**Static Factory Method**
생성자와는 별도로 해당 클래스의 인스턴스를 반환  
ex)
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

- 정적 팩토리 메서드가 생성자 보다 좋은 점
    1. **이름을 가질 수 있다.**
        - 반환될 객체의 특성을 쉽게 묘사할 수 있다.
        - ex) 
            ```java
            BigInteger.probablePrime  // 값이 소수인 BigInteger 반환
            ```
    2. **호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.**
        - 인스턴스를 미리 생성, 재활용 함으로 불필요한 객체 생성 방지
    3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**
        - 인터페이스 구현 클래스의 인스턴스를 public으로 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지 가능
        - 클라이언트가 API를 사용하기 위해 익혀야 하는 개념적인 무게도 낮춤
        - 인터페이스 기반 프레임워크를 만드는 핵심 기술
        - ex) `java.util.Collections`
        - 팩토리를 사용하는 코드가 구현체가 아닌 인터페이스 타입으로 코딩 가능
        > - **Java 8** 부터 인터페이스는 **public static method** 를 가질 수 있다.  
        > - **Java 9** 부터는 **private static method** 가능 But, 정적 필드와 정적 멤버 클래스는 여전히 public
    4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
        - 3번의 연장선
        - 클라이언트는 팩토리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수 없고 알 필요도 없음
        - JDK의 변화나 릴리즈가 달라져 새로운 타입을 만들거나 없애도 문제가 되지 않음
        - ex) `EnumSet`클래스는 public 생성자 없이 정적 팩토리만 제공. 원소의 수에 따라 `RegularEnumSet` 또는 `JumboEnumSet` 인스턴스 반환
    5. **정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**
        - 3번 부터 연장되는 '유연함'에 대한 설명
        - **Service Provider Framework** 을 만드는 근간
        - 제공자는 서비스의 구현체. 이 구현체들을 클라이언트에 제공하는 역할을 프레임웍이 통제하여, 클라이언트를 구현체로부터 분리
        - 서비스 제공자 프레임 워크의 핵심 컴포넌트:

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 3장 모든 객체의 공통 메서드

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 4장 클래스와 인터페이스

### :label: Item 15 - "클래스와 멤버의 접근 권한을 최소화하라"

- 잘 설계된 컴포넌트의 특징: **정보은닉 & 캡슐화**
    - 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트부터 잘 숨김
    - API를 통해서만 다른 컴포넌트와 소통. 내부 동작 방식에 개의치 않음.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
    - 꼭 필요한 최소한의 공개 API만 public으로 선언
    - protected 멤버는 공개 API 임
    - 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안된다.
    - 가변적인 public 인스턴스는 일반적으로 thread-safe 하지 않다.
        - 예외: 상수(public static final) - 반드시 기본 타입이나 불변 객체 참조
            > ex) public static final 배열은 변경 가능하므로 주의
- 정보 은닉의 장점:
    1. 시스템 개발 속도를 높인다
    2. 시스템 관리 비용을 낮춘다.
    3. 성능 최적화에 도움
    4. 소프트웨어 재사용성을 높인다.
    5. 큰 시스템을 제작하는 난이도를 낮춘다.

<br/>

### :label: Item 16 - "public 클래스에서는 public 필드가 아닌 접근자 메소드를 사용하라"

- 데이터 필드에 대한 직접 접근의 문제점
    - 캡슐화의 이점을 제공받지 못함
    - API를 수정하지 않고 내부 표현을 바꿀 수 없음
    - 불변식 보장 불가
    - 외부에서 필드에 접근할 떄 부수 작업 수행 불가
- private 필드와 접근자(getter) 사용
    - 가변 필드의 직접 노출 금지
    - 클래스 내부 데이터 표현 방식 변경의 유연성 획득
- package-private 클래스 혹은 private 중첩 클래스에 대해선 예외
    - 해당 클래스가 표현하려는 추상 개념만 올바르게 표현

<br>

### :label: Item 17 - "변경 가능성을 최소화하라"

    불변 클래스: 그 인스턴스의 내부 값을 수정할 수 없는 클래스

- 클래스를 불변으로 설계하는 이유:
    - 설계하고 구현하기 쉬움
    - 오류가 생길 여지가 적고 안전함
    - ex) String, 기본 타입이 박싱된 클래스, BigInteger, BigDecimal 등
- 클래스를 불변으로 만드는 5가지 규칙
    1. 객체의 상태를 변경하는 메소드(변경자)를 제공하지 않는다.
    2. 클래스를 확장할 수 없도록 한다.
        - 간단한 방법: final 클래스로 선언
        - 유연한 방법: **모든 생성자를 private 또는 package-private으로 만들고 public 정적 팩토리 제공**
    3. 모든 필드를 final로 선언한다.
    4. 모든 필드를 private으로 선언한다.
    5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
- 불변 객체의 특징 및 장점
    - 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직
    - thread-safe 하여 따로 동기화할 필요 없음
        > 한번 만든 인스턴스를 공유 및 재활용
    - 정적 팩토리 제공 가능
        > 인스턴스 중복 생성을 방지 및 재활용하여 메모리 사용량과 GC 비용이 줄어듬
    - 방어적 복사(clone)가 필요 없음
    - 불변 객체끼리 내부 데이터 공유 가능
    - 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 그 구조가 복잡하더라도 불변식을 유지하기 수월
    - 실패 원자성 제공
        > 메소드에서 예외가 발생하더라도 그 객체는 여전히 이전과 같이 유효한 상태
- 불변 객체의 단점:
    - 값이 다르다면 반드시 독립된 객체로 만들어야 함

- 정리
    - **클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.**
    - 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
    - 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.

<br>

### :label: Item 18 - "상속보다는 컴포지션을 사용하라"

- 상속이 안전한 경우
    - 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서의 상속
    - 확장할 목적으로 설계되었고 문서화도 잘 된 클래스

- 상속이 안전하지 않은 경우
    - 다른 패키지의 구체 클래스를 상속
    - 즉, 인터페이스 상속이 아닌 클래스가 다른 클래스를 확장하는 구현 상속
        > *이 책에서 말하는 상속*

- 상속의 문제점
    - 메소드 호출과 달리 상속은 캡슐화를 깨뜨린다.
        > 클래스 확장을 고려한다면 문서화 필요
        
        - 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
            1. **자기사용이 존재하는 메소드의 재정의**
                - **'자기사용(self-use)':** 상위 클래스에서 자신의 다른 부분을 사용
                - 자기사용이 있는 메소드를 재정의할 때 의도치 않은 결과가 나타날 수 있다.
                - 자기사용 여부를 알 수 없고 또한 다음 릴리즈에 유지될지도 알 수 없다.
            2. **상위 클래스의 메소드 추가**
                - 하위 클래스에 추가한 메소드와 시그니처가 같고 반환 타입이 다르다면 컴파일조차 불가
                - 하위 클래스에서 메소드를 작성할 때 상위 클래스의 메소드는 존재하지 않아, 상위 클래스의 메소드가 요구하는 규약을 만족하지 못할 가능성이 큼

- 상속의 문제 해결: **Composition(구성)**
    - 방법: 
        - 클래스를 확장하는 대신, private 필드로 기존 클래스의 인스턴스를 참조
    - **전달**(forwarding): 기존 클래스의 메소드를 호출하여 결과 반환
    - **전달 메소드**(forwarding method): 기존 클래스의 메소드를 사용하는 메소드
    - **래퍼 클래스**: 다른 인스턴스를 감싸고 있는 클래스 / *데코레이터 패턴*
    - **위임**(delegation): 컴포지션과 전달의 조합. 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우

- 래퍼 클래스의 단점
    - 래퍼 클래스는 콜백 프레임워크와는 어울리지 않음  
    - **콜백 프레임워크**: 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출(콜백) 때 사용  
    - **SELF 문제**: 내부 객체는 자신을 감싸고 있는 래퍼의 존재를  모르니 대신 자신의 참조를 넘기고, 콜백 때는 래퍼가 아닌 내부 객체를 호출
    - 해결 방법: **전달 클래스** (전달 메소드) 작성 필요
        - 원하는 기능을 덧씌우는 작업 (인터페이스당 하나씩)
        - 재사용 가능

- 상속에 대한 주의점
    - 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 함
        > is-a 관계일 때만
    - 컴포지션을 써야 할 상황에서 상속은 사용하는 건 내부 구현을 불필요하게 노출하는 꼴
        - API가 내부 구현에 묶이고 그 클래스의 성능도 제한됨
        - 클라이언트가 노출된 내부에 직접 접근 가능
        - 클라이언트에서 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 해칠 수 있다.

<br>

### :label: Item 19 - "상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라"

- **상속용 클래스는 재정의 할 수 있는 메소드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.**
    - 내용:
        - 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지
        - 재정의 가능 메소드를 호출할 수 있는 모든 상황 (ex. 백그라운드 스레드나 정적 초기화 과정에서의 호출)
    - API 문서의 "Implementation Requirements": 해당 메소드의 내부 동작 방식 설명
        - 메소드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해 줌
        - 좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다.
    - 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야한다.
        > "좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다"와는 대치

- **클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메소드 형태로 공개해야 할 수도 있다.**
    - ex) java.util.AbstractList의 removeRange: 최종 구현자는 해당 메소드에 관심이 없지만 이 메소드를 사용하는 clear 메소드를 고성능으로 만들기 쉽게 한다.

- **상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일**
    - 상속용으로 설계한 클래스는 배포 전 반드시 하위 클래스를 만들어 검증
        > 보통 3개 정도. 이 중 하나 이상은 제3자가 작성 필요

- **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안된다.**    
    - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행
    - 하위 클래스에서 재정의한 메소드가 하위 클래스의 생성자보다 먼저 실행
    - 재정의한 메소드가 하위 클래스의 생성자에서 초기화 하는 값에 의존하면 오동작 가능성
        > private, final, static 메소드는 재정의가 불가능하니 호출해도 무관

- **Cloneable과 Serializable 인터페이스를 구현한 클래스를 상속할 수 있게 하는 것은 좋지 않은 생각.**
    - 그럼에도 상속을 할 수 있게 하는 방법:
        - clone과 readObject 모두 직간접적으로 재정의 가능 메소드를 호출해서는 안 된다.
        - Serializeable을 구현한 상속용 클래스가 readResolve나 writeReplace 메소드를 갖는다면 private이 아닌 protected로 선언해야 한다.

- 상속에 대한 문제점 해결 방법
    - **상속용으로 설계하지 않은 클래스는 상속을 금지하자.** ([item 17](#label-item-17---변경-가능성을-최소화하라))
        - 방법 1: 클래스를 final로 선언
        - 방법 2: 모든 생성자를 private이나 package-private으로 선언, public 정적 팩토리 제공
    - 인터페이스를 구현한 클래스의 상속 허용 - **래퍼 클래스 패턴** ([item 18](#label-item-18---상속보다는-컴포지션을-사용하라))
    - 인터페이스를 구현하지 않은 구체 클래스의 상속 허용
        - 클래스 내부에서는 재정의 가능 메소드를 사용하지 않게 만들고 문서화로 남김
            > 재정의 가능 메소드를 호출하는 자기 사용 코드를 제거
        - 클래스의 동작을 유지하며 재정의 가능 메소드를 사용하는 코드를 제거하는 방법
            - 재정의 가능 메소드는 자신의 본문 코드를 private '도우미 메소드'로 옮기고, 도우미 메소드를 호출하도록 수정
            - 재정의 가능 메소드를 호출하는 모든 코드들도 도우미 메소드를 호출하도록 수정

<br>

### :label: Item 20 - "추상 클래스보다는 인터페이스를 우선하라"

- 자바의 다중 구현 메커니즘 
    1. 추상 클래스
        - 단일 상속 
        - 추상 클래스가 정의한 타입을 구현한 클래스는 반드시 추상 클래스의 하위 클래스 (새로운 타입을 정의하는 데 제약)
    2. 인터페이스 
        - 다중 상속
        - 어떤 클래스를 상속했든 같은 타입으로 취급
> 자바 8부터 인터페이스도 default method 제공. 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공 가능

<br>

- 인터페이스의 장점
    - **기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.**
        - 인터페이스가 요구하는 메소드만 추가하고, implements 구문만 추가하면 끝
        - 기존 클래스 위에 새로운 추상 클래스를 끼워넣는 것은 어려움
            - 두 클래스가 같은 추상 클래스를 확장하는 것은 해당 추상 클래스는 공통 조상이어야 함
            - 계층 구조에 혼란
    - **인터페이스는 믹스인(Mixin) 정의에 안성맞춤**
        - 믹스인: 클래스가 구현할 수 있는 타입. 원래의 **주된 타입 외에도 특정 선택적 행위를 제공**한다고 선언하는 효과
            > ex) Comparable은 자신을 구현한 클래스의 인스턴스끼리 순서를 정할 수 있다고 선언하는 믹스인 인터페이스
        - 추상 클래스는 기존 클래스에 덧씌울 수 없고, 클래스는 두 부모를 섬길 수 없기에 믹스인 정의 불가
    - **인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.**
        - 타입을 계층적으로 엄격히 구분하기 어려운 개념을 인터페이스로 정의 가능
            > ex) Singer + SongWriter = SingerSongWriter
        - 추상 클래스로 계층화 시킨다면 고도비만 계층구조 또는 조합 폭발(combinatorial explosion) 현상 가능성
    - **래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.**
        - 래퍼 클래스 관용구 -> [item 18](#label-item-18---상속보다는-컴포지션을-사용하라)
        - 타입을 추상 클래스로 정의하면, 해당 타입에 기능을 추가하는 방법은 상속뿐. 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기 쉬움.

<br>

- 인터페이스의 메소드 중 구현 방법이 명백한 것 - **디폴트 메소드 (default method)** 제공 원칙
    - 디폴트 메소드를 제공할 때는 @implSpec을 붙여 문서화해야 한다. ([item 19](#label-item-19---추상-클래스보다는-인터페이스를-우선하라))
    - equals, hashCode 같은 Object 메소드는 default method로 제공해선 안된다.
    - 인터페이스는 인스턴스 필드를 가질 수 없고, public이 아닌 정적 멤버도 가질 수 없다. (private 정적 메소드는 예외)
    - 직접 만들지 않은 인터페이스에는 디폴트 메소드를 추가할 수 없다.

<br>

- **추상 골격 구현 클래스(skeleton implementation class)**
    - 인터페이스와 추상 클래스의 장점을 결합
        - 추상 클래스: 중복되는 코드 제거
        - 인터페이스: 다중 상속
        > 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의 중 따라오는 제약에서 자유로움
    - 구현 방법
        - 인터페이스: 타입 정의, 디폴트 메소드 제공
        - 골격 구현 클래스: 나머지 메소드 구현
            - 관례상 클래스명은 `Abstract[Interface명]`
            > 템플릿 메소드 패턴

- **시뮬레이트한 다중 상속(simulated multiple inheritance)**
    - 래퍼 클래스와 비슷한 골격 구현 클래스의 우회적 사용
    - 골격 구현 클래스를 private 내부 클래스로 정의하고, 각 메소드 호출을 내부 클래스의 인스턴스에 전달

<br>

- 골격 구현 작성 방법
    1. 인터페이스를 잘 살펴 다른 메소드들의 구현에 사용되는 기반 메소드들을 선정
    2. 기반 메소드들을 사용해 직접 구현할 수 있는 메소드를 모두 디폴트 메소드로 제공
    3. 기반 메소드나 디폴트 메소드로 만들지 못한 메소드가 있다면, 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메소드들은 작성한다.
        > - 만약 인터페이스의 모든 메소드가 기반 메소드와 기폴트 메소드가 된다면 골격 구현 클래스를 별도로 만들 필요 없다.
        > - 골격 구현 클래스에는 필요하다면 public이 아닌 필드와 메소드를 추가해도 된다.
        > - 골격 구현은 기본적으로 상속해서 사용하는 것을 가정하므로 item 19에서의 설계 및 문서화 지침을 따라야 한다.

<br>

- **단순 구현**
    - 골격 구현의 작은 변종
    - 골격 구현과 같이 상속을 위해 인터페이스를 구현한 것이지만, 추상 클래스가 아니다.
    - 동작하는 가장 단순한 구현 (필요에 따라 확장 가능)

<br>

### :label: Item 21 - "인터페이스는 구현하는 쪽을 생각해 설계하라"

- **자바 8**과 **디폴트 메소드**(default method)
    - 자바 8 이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 메소드를 추가할 방법이 없었음
        > 기존에는 '*현재의 인터페이스에 새로운 메소드가 추가될 일은 영원히 없다*'고 가정하고 작성됨
    - 자바 8 이후 디폴트 메소드로 기존 인터페이스에 메소드 추가 가능
    - 하지만 디폴트 메소드는 구현 클래스에 대해 아무것도 모른 채 합의 없이 **무작정 삽입**될 뿐이다.
    - 자바 8 에서 핵심 컬렉션 인터페이스에 다수의 디폴트 메소드 추가 *(주로 **람다식**을 활용하기 위함)*

<br>

1. **생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메소드를 작성하기란 어려운 법이다.**
    - 최대한 범용적으로 구현하여도, 모든 구현체와 잘 어우러지는 것은 아니다.
    - ex) Collection 인터페이스의 removeIf() / SynchronizedCollection

<br>

2. **디폴트 메소드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.**
    - 기존 인터페이스에 디폴트 메소드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.
        - 추가하려는 디폴트 메소드가 기존 구현체들과의 충돌 가능성 존재
    - 디폴트 메소드는 인터페이스로부터 메소드를 제거하거나 기존 메소드의 시그니처를 수정하는 용도가 아니다.
        - 기존 클라이언트를 망가뜨릴 가능성 존재
    - 반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메소드 구현을 제공하는 데 유용한 수단

<br>

3. **인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.**
    - 새로운 인터페이스라면 릴리즈 전에 반드시 테스트를 거쳐야 한다.
        - 서로 다른 방식으로 최소한 세 가지는 구현
        - 각 인스턴스를 다양한 작업에 활용하는 클라이언트도 생성 및 확인 필요
    - 새 인터페이스가 의도한 용도에 잘 부합하는지 확인

<br>

4. **인터페이스를 릴리즈한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.**

<br>

### :label: Item 22 - "인터페이스는 타입을 정의하는 용도로만 사용하라"

- 인터페이스란?
    - 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할
    - 인터페이스를 구현한다는 것 - **자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에게 이야기해주는 것**

<br>

- **상수 인터페이스** 안티패턴은 인터페이스를 잘못 사용한 예
    - "**절대 사용 금지!**"
    - 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아닌 내부 구현에 해당
    - 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위
    - 사용자에게 혼란 야기 / 클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속

- 상수를 공개할 목적이라면..
    - 특정 클래스나 인터페이스에 강하게 연관된 상수라면, 그 클래스나 인터페이스 자체에 추가
        > ex) Integer나 Double의 MIN_VALUE, MAX_VALUE 상수
    - Enum (열거 타입)
    - 인스턴스화할 수 없는 유틸리티 클래스에 담아 공개

<br>

### :label: Item 23 - "태그 달린 클래스보다는 클래스 계층구조를 활용하라"

- 태그 달린 클래스
    - 용도:
        - 두 가지 이상의 의미를 표현할 수 있으며, 그중 현재 표현하는 의미를 태그 값으로 알려줌
    - 단점:
        - 쓸데없는 코드가 많다.
            - 열거 타입 선언, 태그 필드, switch 문 등
        - 가독성 저하
            - 여러 구현이 한 클래스에 혼합돼 있음
        - 메모리를 많이 사용
            - 다른 의미를 위한 코드 포함
        - 필드를 final로 선언하려면 해당 의미에 쓰이지 않는 필드까지 생성자에서 초기화 필요
        - 또 다른 의미를 추가하려면 코드 수정이 불가피 & 오류 발생 가능성
        - 인스턴스의 타입만으로는 현재 나타내는 의미를 알 길이 전혀 없다.
    - **태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.**
        - 클래스 계층 구조를 어설프게 흉내낸 아류일 뿐이다.

```java
class Figure {
    enum Shape { RECTANGLE, CIRCLE };
    // 태그 필드 - 현재 모양을 나타낸다.
    final Shape shape;

    // 다음 필드들은 모양이 사각형(RECTANGLE)일 때만 쓰인다.
    double length;
    double width;

    // 다음 필드는 모양이 원(CIRCLE)일 때만 쓰인다.
    double radius;

    // 원용 생성자
    Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }

    // 사각형용 생성자
    Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError(shape);
        }
    }
}
```

<br>

- **클래스 계층 구조**로 바꾸는 방법
    1. 계층 구조의 root가 될 추상 클래스 정의
    2. 태그 값에 따라 동작이 달라지는 메소드들을 루트 클래스의 추상 메소드로 선언
    3. 태그 값에 상관없이 동작이 일정한 메소드들을 루트 클래스에 일반 메소드로 추가
    4. 모든 하위 클래스에서 공통으로 사용하는 데이터 필드도 루트 클래스로 올림
    5. 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의

```java
abstract class Figure {
    abstract double area();
}

class Circle extends Figure {
    final double radius;

    Circle(double radius) { this.radius = radius; }

    @Override double area() { return Math.PI * (radius * radius); }
}

class Rectangle extends Figure {
    final double length;
    final double width;

    Rectangle(double length, double width) {
        this.length = length;
        this.width  = width;
    }

    @Override double area() { return length * width; }
}
```

<br>

### :label: Item 24 - "멤버 클래스는 되도록 static으로 만들라"

- **중첩 클래스(nested class)**: 다른 클래스 안에 정의된 클래스
    - 종류:
        - 정적 멤버 클래스
        - (비정적) 멤버 클래스
        - 익명 클래스
        - 지역 클래스
        > 정적 멤버 클래스를 제외한 나머지는 **내부 클래스(inner class)** 에 해당
    - 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다.

<br>

1. **정적 멤버 클래스**
    - 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다.
    - 이외에는 일반 클래스와 동일
    - 다른 정적 멤버와 똑같은 접근 규칙 적용받음
        > ex) private으로 선언하면 바깥 클래스에서만 접근 가능
    - 흔히 바깥 클래스와 함께 쓰일 때만 유용한 **public 도우미 클래스**로 쓰임
        > ex) Calculator 클래스의 Operation 열거 타입을 public 정적 클래스로 사용
        > - Calculator.Operation.PLUS
        > - Calculator.Operation.MINUS

<br>

2. **비정적 멤버 클래스**
    - 정적 멤버 클래스와의 차이:
        - 구문상: static 유무
        - 의미상:
            - 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결
            - 비정적 멤버 클래스의 인스턴스 메소드에서 **정규화된 this** (`클래스명.this`)를 사용해 바깥 인스턴스의 메소드를 호출하거나 참조를 가져올 수 있다.
    - **비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없다.**
        - 비정적 멤버 클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스가 인스턴스화될 때 확립되며, 더 이상 변경할 수 없다.
        - 가끔 직접 `바깥 인스턴스의 클래스.new MemberClass(args)`를 호출해 수동으로 만들기도 하지만, 이 관계 정보는 비정적 멤버 클래스의 인스턴스 안에 만들어져 메모리 공간을 차지하고 생성 시간도 더 걸린다.
        > 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 **정적 멤버 클래스**로 만들어야 한다.
    - **비정적 멤버 클래스는 "어댑터"를 정의할 때 자주 쓰인다.**
        - 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용
        - Ex) Map 인터페이스의 구현체들은 보톤 자신의 컬렉션 뷰를 구현할 때 비정적 멤버 클래스 사용
    - **멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자**
        - static이 없으면 숨은 외부 참조를 갖게 되고, 이 참조를 저장하려면 시간과 공간이 소비된다.
        - GC가 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 발생할 수 있다.
    - **private 정적 멤버 클래스**는 흔히 바깥 클래스가 표현하는 객체의 한 부분(구성요소)을 나타낼 때 사용

<br>

3. **익명 클래스**
    - 특징:
        - 이름이 없다.
        - 바깥 클래스의 멤버가 아니다.
        - 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다.
        - 코드의 어디서든 만들 수 있다.
        - 오직 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.
        - 정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다.
            - 상수 표현을 위해 초기화된 final 기본 타입과 문자열 필드만 가질 수 있다.
    - 응용하는 데 제약이 많다.
        - 선언한 지점에서만 인스턴스를 만들 수 있다.
        - instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
        - 여러 인터페이스를 구현할 수 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수도 없다.
        - 상위 타입에서 상속한 멤버 외에는 호출할 수 옶다.
        - 표현식 중간에 등장하므로 (10줄 이하로) 짧지 않으면 가독성이 떨어진다.
    - 사용:
        - 자바 8 이전: 즉석에서 작은 함수 객체나 처리 객체를 만들 때 주로 사용
        - 자바 8 이후: 람다식 사용
        - 정적 팩토리 메소드 구현시 사용

<br>

4. **지역 클래스**
    - 가장 드물게 사용
    - 지역 변수를 선언할 수 있는 곳이면 어디든 선언 가능
    - 유효 범위는 지역 변수와 같다.
    - 멤버 클래스처럼 이름이 있고 반복해서 사용 가능
    - 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스 참조 가능
    - 정적 멤버를 가질 수 없음
    - 가독성을 위해 짧게 작성 필요

<br>

- 정리
    - 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 **멤버 클래스**로 만든다.
    - 멤버 클래스의 인스턴스가 바깥 인스턴스를 참조한다면 **비정적**으로, 그렇지 않다면 **정적**으로 만든다.
    - 중첩 클래스가 한 메소드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 **익명 클래스**. 그렇지 않으면 **지역 클래스**로 만든다.

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 5장 제네릭

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 6장 열거 타입과 애너테이션

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 7장 람다와 스트림

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 8장 메서드

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 9장 일반적인 프로그래밍 원칙

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 10장 예외

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 11장 동시성

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 12장 직렬화

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>
