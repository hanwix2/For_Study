# Effective Java

### :paperclip: Contents

2. [객체 생성과 파괴](#2장-객체-생성과-파괴)
3. [모든 객체의 공통 메서드](#3장-모든-객체의-공통-메서드)
4. [클래스와 인터페이스](#4장-클래스와-인터페이스)
5. [제네릭](#5장-제네릭)
6. [열거 타입과 애너테이션](#6장-열거-타입과-애너테이션)
7. [람다와 스트림](#7장-람다와-스트림)
8. [메서드](#8장-메서드)
9. [일반적인 프로그래밍 원칙](#9장-일반적인-프로그래밍-원칙)
10. [예외](#10장-예외)
11. [동시성](#11장-동시성)
12. [직렬화](#12장-직렬화)

---

## 2장 객체 생성과 파괴

### :label: Item 1 - "생성자 대신 정적 팩토리 메서드를 고려하라"

**Static Factory Method**
생성자와는 별도로 해당 클래스의 인스턴스를 반환  
ex)
```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

- 정적 팩토리 메서드가 생성자 보다 좋은 점
    1. **이름을 가질 수 있다.**
        - 반환될 객체의 특성을 쉽게 묘사할 수 있다.
        - ex) 
            ```java
            BigInteger.probablePrime  // 값이 소수인 BigInteger 반환
            ```
    2. **호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.**
        - 인스턴스를 미리 생성, 재활용 함으로 불필요한 객체 생성 방지
    3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**
        - 인터페이스 구현 클래스의 인스턴스를 public으로 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지 가능
        - 클라이언트가 API를 사용하기 위해 익혀야 하는 개념적인 무게도 낮춤
        - 인터페이스 기반 프레임워크를 만드는 핵심 기술
        - ex) `java.util.Collections`
        - 팩토리를 사용하는 코드가 구현체가 아닌 인터페이스 타입으로 코딩 가능
        > - **Java 8** 부터 인터페이스는 **public static method** 를 가질 수 있다.  
        > - **Java 9** 부터는 **private static method** 가능 But, 정적 필드와 정적 멤버 클래스는 여전히 public
    4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
        - 3번의 연장선
        - 클라이언트는 팩토리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수 없고 알 필요도 없음
        - JDK의 변화나 릴리즈가 달라져 새로운 타입을 만들거나 없애도 문제가 되지 않음
        - ex) `EnumSet`클래스는 public 생성자 없이 정적 팩토리만 제공. 원소의 수에 따라 `RegularEnumSet` 또는 `JumboEnumSet` 인스턴스 반환
    5. **정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**
        - 3번 부터 연장되는 '유연함'에 대한 설명
        - **Service Provider Framework** 을 만드는 근간
        - 제공자는 서비스의 구현체. 이 구현체들을 클라이언트에 제공하는 역할을 프레임웍이 통제하여, 클라이언트를 구현체로부터 분리
        - 서비스 제공자 프레임 워크의 핵심 컴포넌트:

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 3장 모든 객체의 공통 메서드

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 4장 클래스와 인터페이스

### :label: Item 15 - "클래스와 멤버의 접근 권한을 최소화하라"

- 잘 설계된 컴포넌트의 특징: **정보은닉 & 캡슐화**
    - 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트부터 잘 숨김
    - API를 통해서만 다른 컴포넌트와 소통. 내부 동작 방식에 개의치 않음.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
    - 꼭 필요한 최소한의 공개 API만 public으로 선언
    - protected 멤버는 공개 API 임
    - 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안된다.
    - 가변적인 public 인스턴스는 일반적으로 thread-safe 하지 않다.
        - 예외: 상수(public static final) - 반드시 기본 타입이나 불변 객체 참조
            > ex) public static final 배열은 변경 가능하므로 주의
- 정보 은닉의 장점:
    1. 시스템 개발 속도를 높인다
    2. 시스템 관리 비용을 낮춘다.
    3. 성능 최적화에 도움
    4. 소프트웨어 재사용성을 높인다.
    5. 큰 시스템을 제작하는 난이도를 낮춘다.

<br/>

### :label: Item 16 - "public 클래스에서는 public 필드가 아닌 접근자 메소드를 사용하라"

- 데이터 필드에 대한 직접 접근의 문제점
    - 캡슐화의 이점을 제공받지 못함
    - API를 수정하지 않고 내부 표현을 바꿀 수 없음
    - 불변식 보장 불가
    - 외부에서 필드에 접근할 떄 부수 작업 수행 불가
- private 필드와 접근자(getter) 사용
    - 가변 필드의 직접 노출 금지
    - 클래스 내부 데이터 표현 방식 변경의 유연성 획득
- package-private 클래스 혹은 private 중첩 클래스에 대해선 예외
    - 해당 클래스가 표현하려는 추상 개념만 올바르게 표현

<br>

### :label: Item 17 - "변경 가능성을 최소화하라"

    불변 클래스: 그 인스턴스의 내부 값을 수정할 수 없는 클래스

- 클래스를 불변으로 설계하는 이유:
    - 설계하고 구현하기 쉬움
    - 오류가 생길 여지가 적고 안전함
    - ex) String, 기본 타입이 박싱된 클래스, BigInteger, BigDecimal 등
- 클래스를 불변으로 만드는 5가지 규칙
    1. 객체의 상태를 변경하는 메소드(변경자)를 제공하지 않는다.
    2. 클래스를 확장할 수 없도록 한다.
        - 간단한 방법: final 클래스로 선언
        - 유연한 방법: **모든 생성자를 private 또는 package-private으로 만들고 public 정적 팩토리 제공**
    3. 모든 필드를 final로 선언한다.
    4. 모든 필드를 private으로 선언한다.
    5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
- 불변 객체의 특징 및 장점
    - 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직
    - thread-safe 하여 따로 동기화할 필요 없음
        > 한번 만든 인스턴스를 공유 및 재활용
    - 정적 팩토리 제공 가능
        > 인스턴스 중복 생성을 방지 및 재활용하여 메모리 사용량과 GC 비용이 줄어듬
    - 방어적 복사(clone)가 필요 없음
    - 불변 객체끼리 내부 데이터 공유 가능
    - 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 그 구조가 복잡하더라도 불변식을 유지하기 수월
    - 실패 원자성 제공
        > 메소드에서 예외가 발생하더라도 그 객체는 여전히 이전과 같이 유효한 상태
- 불변 객체의 단점:
    - 값이 다르다면 반드시 독립된 객체로 만들어야 함

- 정리
    - **클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.**
    - 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
    - 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.

<br>

### :label: Item 18 - "상속보다는 컴포지션을 사용하라"

- 상속이 안전한 경우
    - 상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서의 상속
    - 확장할 목적으로 설계되었고 문서화도 잘 된 클래스

- 상속이 안전하지 않은 경우
    - 다른 패키지의 구체 클래스를 상속
    - 즉, 인터페이스 상속이 아닌 클래스가 다른 클래스를 확장하는 구현 상속
        > *이 책에서 말하는 상속*

- 상속의 문제점
    - 메소드 호출과 달리 상속은 캡슐화를 깨뜨린다.
        > 클래스 확장을 고려한다면 문서화 필요
        
        - 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
            1. **자기사용이 존재하는 메소드의 재정의**
                - **'자기사용(self-use)':** 상위 클래스에서 자신의 다른 부분을 사용
                - 자기사용이 있는 메소드를 재정의할 때 의도치 않은 결과가 나타날 수 있다.
                - 자기사용 여부를 알 수 없고 또한 다음 릴리즈에 유지될지도 알 수 없다.
            2. **상위 클래스의 메소드 추가**
                - 하위 클래스에 추가한 메소드와 시그니처가 같고 반환 타입이 다르다면 컴파일조차 불가
                - 하위 클래스에서 메소드를 작성할 때 상위 클래스의 메소드는 존재하지 않아, 상위 클래스의 메소드가 요구하는 규약을 만족하지 못할 가능성이 큼

- 상속의 문제 해결: **Composition(구성)**
    - 방법: 
        - 클래스를 확장하는 대신, private 필드로 기존 클래스의 인스턴스를 참조
    - **전달**(forwarding): 기존 클래스의 메소드를 호출하여 결과 반환
    - **전달 메소드**(forwarding method): 기존 클래스의 메소드를 사용하는 메소드
    - **래퍼 클래스**: 다른 인스턴스를 감싸고 있는 클래스 / *데코레이터 패턴*
    - **위임**(delegation): 컴포지션과 전달의 조합. 래퍼 객체가 내부 객체에 자기 자신의 참조를 넘기는 경우

- 래퍼 클래스의 단점
    - 래퍼 클래스는 콜백 프레임워크와는 어울리지 않음  
    - **콜백 프레임워크**: 자기 자신의 참조를 다른 객체에 넘겨서 다음 호출(콜백) 때 사용  
    - **SELF 문제**: 내부 객체는 자신을 감싸고 있는 래퍼의 존재를  모르니 대신 자신의 참조를 넘기고, 콜백 때는 래퍼가 아닌 내부 객체를 호출
    - 해결 방법: **전달 클래스** (전달 메소드) 작성 필요
        - 원하는 기능을 덧씌우는 작업 (인터페이스당 하나씩)
        - 재사용 가능

- 상속에 대한 주의점
    - 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상황에서만 쓰여야 함
        > is-a 관계일 때만
    - 컴포지션을 써야 할 상황에서 상속은 사용하는 건 내부 구현을 불필요하게 노출하는 꼴
        - API가 내부 구현에 묶이고 그 클래스의 성능도 제한됨
        - 클라이언트가 노출된 내부에 직접 접근 가능
        - 클라이언트에서 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 해칠 수 있다.

<br>

### :label: Item 19 - "상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라"

- **상속용 클래스는 재정의 할 수 있는 메소드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.**
    - 내용:
        - 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지
        - 재정의 가능 메소드를 호출할 수 있는 모든 상황 (ex. 백그라운드 스레드나 정적 초기화 과정에서의 호출)
    - API 문서의 "Implementation Requirements": 해당 메소드의 내부 동작 방식 설명
        - 메소드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해 줌
        - 좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다.
    - 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야한다.
        > "좋은 API 문서란 '어떻게'가 아닌 '무엇'을 하는지를 설명해야 한다"와는 대치

- **클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메소드 형태로 공개해야 할 수도 있다.**
    - ex) java.util.AbstractList의 removeRange: 최종 구현자는 해당 메소드에 관심이 없지만 이 메소드를 사용하는 clear 메소드를 고성능으로 만들기 쉽게 한다.

- **상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일**
    - 상속용으로 설계한 클래스는 배포 전 반드시 하위 클래스를 만들어 검증
        > 보통 3개 정도. 이 중 하나 이상은 제3자가 작성 필요

- **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안된다.**    
    - 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행
    - 하위 클래스에서 재정의한 메소드가 하위 클래스의 생성자보다 먼저 실행
    - 재정의한 메소드가 하위 클래스의 생성자에서 초기화 하는 값에 의존하면 오동작 가능성
        > private, final, static 메소드는 재정의가 불가능하니 호출해도 무관

- **Cloneable과 Serializable 인터페이스를 구현한 클래스를 상속할 수 있게 하는 것은 좋지 않은 생각.**
    - 그럼에도 상속을 할 수 있게 하는 방법:
        - clone과 readObject 모두 직간접적으로 재정의 가능 메소드를 호출해서는 안 된다.
        - Serializeable을 구현한 상속용 클래스가 readResolve나 writeReplace 메소드를 갖는다면 private이 아닌 protected로 선언해야 한다.

- 상속에 대한 문제점 해결 방법
    - **상속용으로 설계하지 않은 클래스는 상속을 금지하자.** ([item 17](#label-item-17---변경-가능성을-최소화하라))
        - 방법 1: 클래스를 final로 선언
        - 방법 2: 모든 생성자를 private이나 package-private으로 선언, public 정적 팩토리 제공
    - 인터페이스를 구현한 클래스의 상속 허용 - **래퍼 클래스 패턴** ([item 18](#label-item-18---상속보다는-컴포지션을-사용하라))
    - 인터페이스를 구현하지 않은 구체 클래스의 상속 허용
        - 클래스 내부에서는 재정의 가능 메소드를 사용하지 않게 만들고 문서화로 남김
            > 재정의 가능 메소드를 호출하는 자기 사용 코드를 제거
        - 클래스의 동작을 유지하며 재정의 가능 메소드를 사용하는 코드를 제거하는 방법
            - 재정의 가능 메소드는 자신의 본문 코드를 private '도우미 메소드'로 옮기고, 도우미 메소드를 호출하도록 수정
            - 재정의 가능 메소드를 호출하는 모든 코드들도 도우미 메소드를 호출하도록 수정

<br>

### :label: Item 20 - "추상 클래스보다는 인터페이스를 우선하라"

- 자바의 다중 구현 메커니즘 
    1. 추상 클래스
        - 단일 상속 
        - 추상 클래스가 정의한 타입을 구현한 클래스는 반드시 추상 클래스의 하위 클래스 (새로운 타입을 정의하는 데 제약)
    2. 인터페이스 
        - 다중 상속
        - 어떤 클래스를 상속했든 같은 타입으로 취급
> 자바 8부터 인터페이스도 default method 제공. 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공 가능

<br>

- 인터페이스의 장점
    - **기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.**
        - 인터페이스가 요구하는 메소드만 추가하고, implements 구문만 추가하면 끝
        - 기존 클래스 위에 새로운 추상 클래스를 끼워넣는 것은 어려움
            - 두 클래스가 같은 추상 클래스를 확장하는 것은 해당 추상 클래스는 공통 조상이어야 함
            - 계층 구조에 혼란
    - **인터페이스는 믹스인(Mixin) 정의에 안성맞춤**
        - 믹스인: 클래스가 구현할 수 있는 타입. 원래의 **주된 타입 외에도 특정 선택적 행위를 제공**한다고 선언하는 효과
            > ex) Comparable은 자신을 구현한 클래스의 인스턴스끼리 순서를 정할 수 있다고 선언하는 믹스인 인터페이스
        - 추상 클래스는 기존 클래스에 덧씌울 수 없고, 클래스는 두 부모를 섬길 수 없기에 믹스인 정의 불가
    - **인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다.**
        - 타입을 계층적으로 엄격히 구분하기 어려운 개념을 인터페이스로 정의 가능
            > ex) Singer + SongWriter = SingerSongWriter
        - 추상 클래스로 계층화 시킨다면 고도비만 계층구조 또는 조합 폭발(combinatorial explosion) 현상 가능성
    - **래퍼 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.**
        - 래퍼 클래스 관용구 -> [item 18](#label-item-18---상속보다는-컴포지션을-사용하라)
        - 타입을 추상 클래스로 정의하면, 해당 타입에 기능을 추가하는 방법은 상속뿐. 상속해서 만든 클래스는 래퍼 클래스보다 활용도가 떨어지고 깨지기 쉬움.

<br>

- 인터페이스의 메소드 중 구현 방법이 명백한 것 - **디폴트 메소드 (default method)** 제공 원칙
    - 디폴트 메소드를 제공할 때는 @implSpec을 붙여 문서화해야 한다. ([item 19](#label-item-19---추상-클래스보다는-인터페이스를-우선하라))
    - equals, hashCode 같은 Object 메소드는 default method로 제공해선 안된다.
    - 인터페이스는 인스턴스 필드를 가질 수 없고, public이 아닌 정적 멤버도 가질 수 없다. (private 정적 메소드는 예외)
    - 직접 만들지 않은 인터페이스에는 디폴트 메소드를 추가할 수 없다.

<br>

- **추상 골격 구현 클래스(skeleton implementation class)**
    - 인터페이스와 추상 클래스의 장점을 결합
        - 추상 클래스: 중복되는 코드 제거
        - 인터페이스: 다중 상속
        > 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의 중 따라오는 제약에서 자유로움
    - 구현 방법
        - 인터페이스: 타입 정의, 디폴트 메소드 제공
        - 골격 구현 클래스: 나머지 메소드 구현
            - 관례상 클래스명은 `Abstract[Interface명]`
            > 템플릿 메소드 패턴

- **시뮬레이트한 다중 상속(simulated multiple inheritance)**
    - 래퍼 클래스와 비슷한 골격 구현 클래스의 우회적 사용
    - 골격 구현 클래스를 private 내부 클래스로 정의하고, 각 메소드 호출을 내부 클래스의 인스턴스에 전달

<br>

- 골격 구현 작성 방법
    1. 인터페이스를 잘 살펴 다른 메소드들의 구현에 사용되는 기반 메소드들을 선정
    2. 기반 메소드들을 사용해 직접 구현할 수 있는 메소드를 모두 디폴트 메소드로 제공
    3. 기반 메소드나 디폴트 메소드로 만들지 못한 메소드가 있다면, 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메소드들은 작성한다.
        > - 만약 인터페이스의 모든 메소드가 기반 메소드와 기폴트 메소드가 된다면 골격 구현 클래스를 별도로 만들 필요 없다.
        > - 골격 구현 클래스에는 필요하다면 public이 아닌 필드와 메소드를 추가해도 된다.
        > - 골격 구현은 기본적으로 상속해서 사용하는 것을 가정하므로 item 19에서의 설계 및 문서화 지침을 따라야 한다.

<br>

- **단순 구현**
    - 골격 구현의 작은 변종
    - 골격 구현과 같이 상속을 위해 인터페이스를 구현한 것이지만, 추상 클래스가 아니다.
    - 동작하는 가장 단순한 구현 (필요에 따라 확장 가능)

<br>

### :label: Item 21 - "인터페이스는 구현하는 쪽을 생각해 설계하라"

- **자바 8**과 **디폴트 메소드**(default method)
    - 자바 8 이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 메소드를 추가할 방법이 없었음
        > 기존에는 '*현재의 인터페이스에 새로운 메소드가 추가될 일은 영원히 없다*'고 가정하고 작성됨
    - 자바 8 이후 디폴트 메소드로 기존 인터페이스에 메소드 추가 가능
    - 하지만 디폴트 메소드는 구현 클래스에 대해 아무것도 모른 채 합의 없이 **무작정 삽입**될 뿐이다.
    - 자바 8 에서 핵심 컬렉션 인터페이스에 다수의 디폴트 메소드 추가 *(주로 **람다식**을 활용하기 위함)*

<br>

1. **생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메소드를 작성하기란 어려운 법이다.**
    - 최대한 범용적으로 구현하여도, 모든 구현체와 잘 어우러지는 것은 아니다.
    - ex) Collection 인터페이스의 removeIf() / SynchronizedCollection

<br>

2. **디폴트 메소드는 (컴파일에 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다.**
    - 기존 인터페이스에 디폴트 메소드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.
        - 추가하려는 디폴트 메소드가 기존 구현체들과의 충돌 가능성 존재
    - 디폴트 메소드는 인터페이스로부터 메소드를 제거하거나 기존 메소드의 시그니처를 수정하는 용도가 아니다.
        - 기존 클라이언트를 망가뜨릴 가능성 존재
    - 반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메소드 구현을 제공하는 데 유용한 수단

<br>

3. **인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.**
    - 새로운 인터페이스라면 릴리즈 전에 반드시 테스트를 거쳐야 한다.
        - 서로 다른 방식으로 최소한 세 가지는 구현
        - 각 인스턴스를 다양한 작업에 활용하는 클라이언트도 생성 및 확인 필요
    - 새 인터페이스가 의도한 용도에 잘 부합하는지 확인

<br>

4. **인터페이스를 릴리즈한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.**

<br>

### :label: Item 22 - "인터페이스는 타입을 정의하는 용도로만 사용하라"

- 인터페이스란?
    - 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할
    - 인터페이스를 구현한다는 것 - **자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에게 이야기해주는 것**

<br>

- **상수 인터페이스** 안티패턴은 인터페이스를 잘못 사용한 예
    - "**절대 사용 금지!**"
    - 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아닌 내부 구현에 해당
    - 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위
    - 사용자에게 혼란 야기 / 클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속

- 상수를 공개할 목적이라면..
    - 특정 클래스나 인터페이스에 강하게 연관된 상수라면, 그 클래스나 인터페이스 자체에 추가
        > ex) Integer나 Double의 MIN_VALUE, MAX_VALUE 상수
    - Enum (열거 타입)
    - 인스턴스화할 수 없는 유틸리티 클래스에 담아 공개

<br>

### :label: Item 23 - "태그 달린 클래스보다는 클래스 계층구조를 활용하라"

- 태그 달린 클래스
    - 용도:
        - 두 가지 이상의 의미를 표현할 수 있으며, 그중 현재 표현하는 의미를 태그 값으로 알려줌
    - 단점:
        - 쓸데없는 코드가 많다.
            - 열거 타입 선언, 태그 필드, switch 문 등
        - 가독성 저하
            - 여러 구현이 한 클래스에 혼합돼 있음
        - 메모리를 많이 사용
            - 다른 의미를 위한 코드 포함
        - 필드를 final로 선언하려면 해당 의미에 쓰이지 않는 필드까지 생성자에서 초기화 필요
        - 또 다른 의미를 추가하려면 코드 수정이 불가피 & 오류 발생 가능성
        - 인스턴스의 타입만으로는 현재 나타내는 의미를 알 길이 전혀 없다.
    - **태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다.**
        - 클래스 계층 구조를 어설프게 흉내낸 아류일 뿐이다.

```java
class Figure {
    enum Shape { RECTANGLE, CIRCLE };
    // 태그 필드 - 현재 모양을 나타낸다.
    final Shape shape;

    // 다음 필드들은 모양이 사각형(RECTANGLE)일 때만 쓰인다.
    double length;
    double width;

    // 다음 필드는 모양이 원(CIRCLE)일 때만 쓰인다.
    double radius;

    // 원용 생성자
    Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }

    // 사각형용 생성자
    Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError(shape);
        }
    }
}
```

<br>

- **클래스 계층 구조**로 바꾸는 방법
    1. 계층 구조의 root가 될 추상 클래스 정의
    2. 태그 값에 따라 동작이 달라지는 메소드들을 루트 클래스의 추상 메소드로 선언
    3. 태그 값에 상관없이 동작이 일정한 메소드들을 루트 클래스에 일반 메소드로 추가
    4. 모든 하위 클래스에서 공통으로 사용하는 데이터 필드도 루트 클래스로 올림
    5. 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의

```java
abstract class Figure {
    abstract double area();
}

class Circle extends Figure {
    final double radius;

    Circle(double radius) { this.radius = radius; }

    @Override double area() { return Math.PI * (radius * radius); }
}

class Rectangle extends Figure {
    final double length;
    final double width;

    Rectangle(double length, double width) {
        this.length = length;
        this.width  = width;
    }

    @Override double area() { return length * width; }
}
```

<br>

### :label: Item 24 - "멤버 클래스는 되도록 static으로 만들라"

- **중첩 클래스(nested class)**: 다른 클래스 안에 정의된 클래스
    - 종류:
        - 정적 멤버 클래스
        - (비정적) 멤버 클래스
        - 익명 클래스
        - 지역 클래스
        > 정적 멤버 클래스를 제외한 나머지는 **내부 클래스(inner class)** 에 해당
    - 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다.

<br>

1. **정적 멤버 클래스**
    - 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다.
    - 이외에는 일반 클래스와 동일
    - 다른 정적 멤버와 똑같은 접근 규칙 적용받음
        > ex) private으로 선언하면 바깥 클래스에서만 접근 가능
    - 흔히 바깥 클래스와 함께 쓰일 때만 유용한 **public 도우미 클래스**로 쓰임
        > ex) Calculator 클래스의 Operation 열거 타입을 public 정적 클래스로 사용
        > - Calculator.Operation.PLUS
        > - Calculator.Operation.MINUS

<br>

2. **비정적 멤버 클래스**
    - 정적 멤버 클래스와의 차이:
        - 구문상: static 유무
        - 의미상:
            - 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결
            - 비정적 멤버 클래스의 인스턴스 메소드에서 **정규화된 this** (`클래스명.this`)를 사용해 바깥 인스턴스의 메소드를 호출하거나 참조를 가져올 수 있다.
    - **비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없다.**
        - 비정적 멤버 클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스가 인스턴스화될 때 확립되며, 더 이상 변경할 수 없다.
        - 가끔 직접 `바깥 인스턴스의 클래스.new MemberClass(args)`를 호출해 수동으로 만들기도 하지만, 이 관계 정보는 비정적 멤버 클래스의 인스턴스 안에 만들어져 메모리 공간을 차지하고 생성 시간도 더 걸린다.
        > 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 **정적 멤버 클래스**로 만들어야 한다.
    - **비정적 멤버 클래스는 "어댑터"를 정의할 때 자주 쓰인다.**
        - 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용
        - Ex) Map 인터페이스의 구현체들은 보톤 자신의 컬렉션 뷰를 구현할 때 비정적 멤버 클래스 사용
    - **멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자**
        - static이 없으면 숨은 외부 참조를 갖게 되고, 이 참조를 저장하려면 시간과 공간이 소비된다.
        - GC가 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 발생할 수 있다.
    - **private 정적 멤버 클래스**는 흔히 바깥 클래스가 표현하는 객체의 한 부분(구성요소)을 나타낼 때 사용

<br>

3. **익명 클래스**
    - 특징:
        - 이름이 없다.
        - 바깥 클래스의 멤버가 아니다.
        - 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다.
        - 코드의 어디서든 만들 수 있다.
        - 오직 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있다.
        - 정적 문맥에서라도 상수 변수 이외의 정적 멤버는 가질 수 없다.
            - 상수 표현을 위해 초기화된 final 기본 타입과 문자열 필드만 가질 수 있다.
    - 응용하는 데 제약이 많다.
        - 선언한 지점에서만 인스턴스를 만들 수 있다.
        - instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
        - 여러 인터페이스를 구현할 수 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수도 없다.
        - 상위 타입에서 상속한 멤버 외에는 호출할 수 옶다.
        - 표현식 중간에 등장하므로 (10줄 이하로) 짧지 않으면 가독성이 떨어진다.
    - 사용:
        - 자바 8 이전: 즉석에서 작은 함수 객체나 처리 객체를 만들 때 주로 사용
        - 자바 8 이후: 람다식 사용
        - 정적 팩토리 메소드 구현시 사용

<br>

4. **지역 클래스**
    - 가장 드물게 사용
    - 지역 변수를 선언할 수 있는 곳이면 어디든 선언 가능
    - 유효 범위는 지역 변수와 같다.
    - 멤버 클래스처럼 이름이 있고 반복해서 사용 가능
    - 익명 클래스처럼 비정적 문맥에서 사용될 때만 바깥 인스턴스 참조 가능
    - 정적 멤버를 가질 수 없음
    - 가독성을 위해 짧게 작성 필요

<br>

- 정리
    - 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 **멤버 클래스**로 만든다.
    - 멤버 클래스의 인스턴스가 바깥 인스턴스를 참조한다면 **비정적**으로 / 그렇지 않다면 **정적**으로 만든다.
    - 중첩 클래스가 한 메소드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 **익명 클래스** / 그렇지 않으면 **지역 클래스**로 만든다.

<br>

### :label: Item 25 - "톱레벨 클래스는 한 파일에 하나만 담으라"

- 하나의 소스 파일에 다수의 톱레벨 클래스
    - 컴파일은 가능
    - 하지만 아무 득이 없고 심각한 위험을 감수해야 하는 행위

<br>

- 문제점:
    - 한 클래스를 여러 가지로 정의
    - 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하냐에 따라 달라짐

<br>

- 굳이 여러 톱레벨 클래스를 한 파일에 담고 싶다면 **정적 멤버 클래스**([item 24](#label-item-24---멤버-클래스는-되도록-static으로-만들라))를 사용하자
    - 읽기 좋고, private으로 선언하면 접근 범위도 최소로 관리 가능

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 5장 제네릭

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 6장 열거 타입과 애너테이션

### :label: Item 34 - "int 상수 대신 열거 타입을 사용하라"

- **열거 타입(Enum):** 일정 개수의 상수 값을 정의한 다음, 그 외의 값은 허용하지 않는 타입

<br>

- 자바에서 열거 타입 지원 전 방법의 단점:
    - **정수 열거 패턴(int enum pattern)**
        - 타입 안전을 보장할 방법이 없다.
            - Ex) Orange를 건네야 할 메소드에 Apple을 보내고 동등 연산자(==)로 비교해도 컴파일러는 아무런 경고 메시지를 출력하지 않는다.
        - 표현력이 좋지 않다.
            - 자바는 정수 열거 패턴을 위한 별도 이름공간(namespace)을 지원하지 않는다.
            - 어쩔 수 없이 접두어를 써서 이름 충돌을 방지한다.
        - 정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다.
            - 평범한 상수를 나열한 것뿐이라 컴파일시 그 값이 클라이언트 파일에 그대로 새겨진다.
            - 상수의 값이 바뀌면 클라이언트도 반드시 다시 컴파일해야 한다.
        - 정수 상수는 문자열로 출력하기 다소 까다롭다.
            - 값을 출력하거나 디버거로 확인시 의미가 아닌 단순 숫자이므로 도움이 되지 않는다.
        - 같은 정수 열거 그룹에 속한 모든 상수를 한 바퀴 순회하는 방법도 마땅치 않다.
            - 그 안에 상수가 몇 개인지도 알 수 없다.
    - **문자열 열거 패턴(string enum pattern)**
        - 정수 열거 패턴보다 더 나쁘다.
        - 상수의 의미를 출력할 수 있다는 점 말고는 장점이 없음.
        - 문자열 그대로 하드코딩 필요
            - 오타가 있어도 컴파일러는 확인 불가
            - 런타임 버그 가능성
        - 문자열 비교에 따른 성능 저하

<br>

- **열거 타입 (enum type)**
    - 자바의 열거 타입은 완전한 형태의 클래스라서 다른 언어의 열거 타입(단순 정수값)보다 훨씬 강력하다.
    - 자바 열거 타입을 뒷받침하는 아이디어
        - 열거 타입 자체는 클래스
        - 상수 하나당 자신의 인스턴스를 하나씩 만들어 `public static final` 필드로 공개한다.
        - 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 `final`
            > - 클라이언트가 인스턴스를 직접 생성, 확장이 불가능
            > - 열거 타입 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재 보장 
            > - 인스턴스 통제됨 (싱글턴을 일반화한 형태)
    - 열거 타입의 장점:
        - 열거 타입은 컴파일타임 타입 안정성을 제공한다.
        - 열거 타입에는 각자의 이름공간이 있어 이름이 같은 상수도 공존한다.
        - 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다.
            - 공개되는 것이 오직 필드의 이름뿐이라 상수 값이 컴파일되어 각인되지 않는다.
        - 열거 타입의 `toString` 메소드는 적절한 문자열을 내어준다.
        - 열거 타입에 임의의 메소드나 필드를 추가할 수 있다.
        - 임의의 인터페이스를 구현하게 할 수 있다.

    - 열거 타입은 실제로는 클래스이므로 고차원의 추상 개념을 표현할 수 있다. (메소드나 필드 추가 가능)
        - 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면 된다.
        - 열거 타입은 근본적으로 불변이라 모든 필드는 final이어야 한다. ([item 17](#label-item-17---변경-가능성을-최소화하라))
        - 필드는 public이 가능하나, private으로 두고 별도의 public 접근자 메소드를 두는 것이 낫다. ([item 16](#label-item-16---public-클래스에서는-public-필드가-아닌-접근자-메소드를-사용하라))

    - 열거 타입은 자신 안에 정의된 상수들의 값을 배열에 담아 반환하는 정적 메소드인 `values`를 제공한다.
        - 선언된 순서로 저장된다.
    - 열거 타입에서 상수를 하나 제거하면 정수 열거 패턴에서는 기대할 수 없는 유용한 메시지를 담은 컴파일 오류 또는 런타임 예외 발생한다.

<br>

- 열거 타입 사용하기
    - 일반 클래스와 마찬가지로, 그 기능을 클라이언트에 노출해야 할 합당한 이유가 없다면 private 또는 package-private으로 선언하라 ([item 15](#label-item-15---클래스와-멤버의-접근-권한을-최소화하라))
    - 널리 쓰이는 열거 타입 -> 톱레벨 클래스로 선언
    - 특정 톱레벨 클래스에만 쓰이는 열거 타입 -> 해당 클래스의 멤버 클래스로 선언

<br>

- 상수마다의 동작 구분
    - switch 문을 이용한 분기
        - 비추천
        - 깨지기 쉽다.
        - 새로운 상수가 추가되면 해당 case 추가 필요
    - **상수별 메소드 구현(constant-specific method implementation)**
        - 열거 타입에 추상 메소드를 선언 후 
        - 각 상수에서 자신에 맞게 재정의 (상수별 클래스 몸체)
        - 메소드가 상수 선언 바로 옆에 붙어 있음
        - 메소드를 재정의 하지 않으면 컴파일 오류
        - 메소드 구현을 상수별 데이터와 결합 가능

<br>

- 열거 타입의 출력
    - 열거 타입에는 상수 이름을 입력받아 해당하는 상수를 반환해주는 `valueOf(String)` 메소드가 자동 생성된다.
    - 열거 타입의 `toString`을 재정의할 땐 `fromString` 메소드도 함께 제공하는 것 고려
        - fromString: toString이 반환하는 문자열을 해당 열거 타입 상수로 변환해주는 메소드

<br>
 

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 7장 람다와 스트림

### :label: Item 42 - "익명 클래스보다는 람다를 사용하라"

- **익명 클래스 방식:**
    - 자바에서 함수 타입을 표현할 때 추상 메소드 하나만 담은 인터페이스(드물게는 추상 클래스)를 사용
    - 이러한 인터페이스의 인스턴스를 **함수 객체**라고 하고, 특정 함수나 동작을 나타내는 데 사용
    - JDK 1.1 이후 함수 객체를 만드는 주요 수단은 **익명 클래스**
    - 전략 패턴에 적합
    - 단점: 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않음

<br>

- **람다식 방식:**
    - 자바 8 이후 추상 메소드 하나짜리 인터페이스는 **함수형 인터페이스**라 불리고 이 인터페이스들의 인스턴스를 람다식을 사용해 만들 수 있게 됨
    - 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하고 어떤 동작을 하는지 명확하게 드러남

<br>

- 람다 사용 Tip
    1. **타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자**
        - 컴파일러가 문맥을 살펴 타입을 추론해 준다.
        - 타입을 명시해야 하는 경우: 
            - 컴파일러 오류 시
            - 반환값이나 람다식 전체를 형변환해야 하는 경우
    2. **코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.**
        - 메소드나 클래스와 달리, 람다는 이름이 없고 문서화도 못 한다.
        - 람다는 한 줄이 가장 좋고 길어햐 세 줄 안에 끝내는 게 좋다. 너무 길면 가독성이 떨어진다.
    3. **람다는 함수형 인터페이스에서만 쓰인다.**
        - 추상 클래스의 인스턴스를 만들 때는 익명 클래스를 사용
        - 추상 메소드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스 사용
    4. **람다는 자신을 참조할 수 없다.**
        - 람다에서의 `this` 키워드는 바깥 인스턴스를 가리킨다.
        - 익명 클래스에서의 `this`는 자기 자신을 가리킨다.
    5. **람다를 직렬화하는 일은 극히 삼가야 한다.**
        - 람다도 익명 클래스처럼 직렬화 형태가 구현별로(가령 가상머신별로) 다를 수 있다.
        - 직렬화해야만 하는 함수 객체가 있다면 private 정적 중첩 클래스([item 24](#label-item-24---멤버-클래스는-되도록-static으로-만들라))의 인스턴스를 사용하자

<br>

- 핵심: 익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들 때만 사용하라

<br>
<br>

### :label: Item 43 - "람다보다는 메소드 참조를 사용하라"

- **메소드 참조(method reference)**
    - 람다보다도 함수 객체를 더 간결하게 만드는 방법
    - 문법: `{클래스이름}::{메소드이름}`
        - 매개변수 생략

<br>

- **메소드 참조를 사용하지 않는 경우:**
    - 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다.
        - 이런 람다는 길이는 더 길지만 메소드 참조보단 읽기 쉽고 유지보수도 쉽다.
    - 람다로 할 수 없는 일이라면 메소드 참조로도 할 수 없다.
        > 람다로 불가능하나 메소드 참조로만 가능한 유일한 것은 '제네릭 함수 타입 구현'

<br>

- **메소드 참조 유형:**
    1. 정적 메소드를 가리키는 메소드 참조 (가장 흔함)
    2. 한정적(bound) 인스턴스 메소드 참조: 수신 객체(참조 대상 인스턴스)를 특정
        - 함수 객체가 받는 인수와 참조되는 메소드가 받는 인수가 같다.
    3. 비한정적(unbound) 인스턴스 메소드 참조: 수신 객체를 특정하지 않음
        - 함수 객체를 적용하는 시점에 수신 객체를 알려준다.
        - 수신 객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메소드 선언에 정의된 매개변수들이 뒤따른다.
        - 주로 스트림 파이프라인에서의 매핑과 필터 함수에 쓰인다. (item 45)
    4. 클래스 생성자를 가리키는 메소드 참조
    5. 배열 생성자를 가리키는 메소드 참조

    | 메소드 참조 유형 | 예 | 같은 기능을 하는 람다 |
    | :------------- |----|----------------------|
    | 정적 | Integer::parseInt | str -> Integer.parseInt(str) |
    | 한정적(인스턴스) | Instant.now()::isAfter | Instant then = Instant.now(); <br> t-> then.isAfter(t) |
    | 비한정적(인스턴스) | String::toLowerCase | str -> str.toLowerCase() |
    | 클래스 생성자 | TreeMap<K, V>::new | () -> new TreeMap<K, V>() |
    | 배열 생성자 | int[]::new | len -> new int[len] |

<br>

- 핵심: 
    - 메소드 참조는 람다의 간단명료한 대안이 될 수 있다.
    - 메소드 참조가 짧고 명확하다면 메소드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라

<br>
<br>

### :label: Item 44 - "표준 함수형 인터페이스를 사용하라"

- 핵심:
    - API를 설계할 때 람다도 염두에 두어야 한다.
    - 입력값과 반환값에 함수형 인터페이스 타입을 활용하라
    - 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택
    - 흔치는 않지만 직접 함수형 인터페이스를 만들어 쓰는 편이 나을 수도 있다.

<br>
<br>

### :label: Item 45 - "스트림은 주의해서 사용하라"

    스트림 API는 다량의 데이터 처리 작업을 돕고자 자바 8에 추가됨

- 스트림 API가 제공하는 추상 개념
    1. **스트림(stream):** 데이터 원소의 유한 혹은 무한 시퀀스(sequence)
        - 스트림의 원소 
            - 객체 참조나 기본 타입 값
            - 출처: 컬렉션, 배열, 파일, 정유표현식 패턴 매처(matcher), 난수 생성기, 다른 스트림 등

    2. **스트림 파이프라인(stream pipeline):** 위 원소들로 수행하는 연산 단계를 표현
        - 형식: [소스 스트림] - [중간 연산] - [종단 연산]
            - 중각 연산은 하나 이상 존재할 수 있으며, 각 연산은 스트림을 어떠한 방식으로 변환한다. (ex. 원소 걸러내기 등)
            - 종단 연산은 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력하는 등 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다.

<br>

- 지연 평가(lazy evaluation)
    - 무한 스트림을 다룰 수 있게 해주는 열쇠
    - 평가는 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않는다.
    - 종단 연산이 없는 스트림 파이프라인은 아무 일도 하지 않는 no-op 과 같으므로, 종단 연산을 빼먹지 말자

- 스트림 API는 메서드 연쇄를 지원하는 플루언트(fluent) API
    - 파이프라인 하나를 구성하는 모든 호출을 연결하여 단 하나의 표현식으로 완성할 수 있다.

-  파이프라인은 기본적으로 순차적으로 수행
    > 파이프라인을 병렬로 실행하려면 parallel 메소드를 호출 (단 효과를 볼 수 있는 상황이 많지는 않다. item 48)

<br>

- 스트림 API 사용이 필수는 아니다!
    - 스트림을 다재다능하여 어떠한 계산도 해낼 수 있고 제대로 사용하면 프로그램이 짧고 깔끔해질 수 있다.
    - 하지만 잘못 사용하면 읽기 어렵고 유지보수도 힘들어진다.

<br>

- 스트림 사용의 노하우
    1. **스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워진다.**
    2. **char 값들을 처리할 때는 스트림을 삼가는 편이 낫다.**
        - 자바는 char 용 스트림을 지원하지 않으므로 형변환 필요
        - 명확성이 떨어지고 잘못 구현할 가능성도 커지며, 느려질 수도 있다.
    3. **기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일 때만 반영하자.**
        - 중간 정도 복잡한 작업은 스트림과 반복문을 적절히 조합하는 것이 최선
        > - 스트림 파이프라인 - 함수 객체 사용
        > - 반복 코드 - 코드 블록 사용
        - **함수 객체로는 할 수 없지만 코드 블록으로는 할 수 있는 일**
            - 범위 안의 지역 변수를 읽고 수정 가능
            - return 문을 사용해 메소드에서 빠져나가거나 , break나 continue 문으로 블록 바깥의 반복문 종료 또는 건너뛸 수 있다.
            - 메소드 선언에 명시된 검사 예외를 던질 수 있다.
        - **스트림을 사용하기 좋은 상황:**
            - 원소들의 시퀀스를 일관되게 변환
            - 원소들의 시퀀스를 필터링
            - 원소들의 시퀀스를 하나의 연산을 사용해 결합 (더하기, 연결하기, 최소값 구하기 등)
            - 원소들의 시퀀스를 컬렉션에 모은다.(공통된 속성을 기준으로 묶으며)
            - 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.
        - **스트림으로 처리하기 어려운 경우:**
            - 한 데이터가 파이프라인의 단계를 통과할 때 각 단계에서의 값들에 동시에 접근하려 할 때 (각 단계마다 원래의 값을 잃는 구조)

<br>
<br>

### :label: Item 46 - "스트림에서는 부작용 없는 함수를 사용하라"

- 스트림 패러다임
    - 스트림은 그저 하나의 API가 아닌, 함수형 프로그래밍에 기초한 패러다임이다.  
    - 스트림 패러다임의 핵심은 **계산을 일련의 변환으로 재구성**하는 부분이다.
        - 각 변환 단계는 가능한 이전 단계의 결과를 받아 처리하는 순수 함수여야 한다.
        - **순수 함수:** 오직 입력만이 결과 영향을 주는 함수. 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않는다.
        - 스트림 연산에 건네는 함수 객체는 모두 부작용이 없어야 한다.

<br>

- **forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산하는 데는 쓰지 말자**
    - 종단 연산인 `forEach` 연산은 종단 연산 중 가장 기능이 적고 덜 스트림다움
    - 모든 연산이 `forEach`에서 일어날 때, 외부 상태를 수정하는 람다를 실행하면 문제 발생 가능 (단순히 연산 결과를 보여주는 일 이상을 수행)
    - 대놓고 반복적이라서 병렬화 불가능
    > 가끔은 스트림 계산 결과를 기존 컬렉션에 추가하는 등의 용도로는 사용 가능

<br>    

- 수집기(Collector / `java.util.stream.Collectors` 클래스)
    - 축소(reduction) 전략을 캡슐화한 블랙박스 객체
        > 축소: 스트림의 원소들을 객체 하나에 취합
    - 수집기를 사용하면 스트림의 원소를 손쉽게 컬렉션으로 모을 수 있다.
        > toList(), toMap(), groupingBy(), toSet(), toCollection(collectionFactory), joining()
    - 스트림을 올바로 사용하려면 수집기를 잘 알아두자

<br>
<br>

### :label: Item 47 - "반환 타입으로는 스트림보다 컬렉션이 낫다"

- 원소 시퀀스를 반환하는 방법(타입)
    - 이전(~ 자바 7):
        - **Collection 인터페이스** - 기본
        - **Iterable 인터페이스** - for-each 문에서만 쓰이거나 일부 Collection 메소드를 구현할 수 없을 때
        - **배열** - 기본 타입 또는 성능에 민감한 상황
    - 스트림 등장(자바 8) 이후:
        - ?

<br>

- 문제: 스트림은 반복(iteration)을 지원하지 않는다. 즉, **for-each로 스트림을 반복할 수 없다.**
    - Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메소드를 전부 포함하고 Iterable 인터페이스가 정의한 방식대로 동작한다.
    - 하지만, *Stream은 Iterable을 확장(extend)하지 않았다.* 
        > for-each로 스트림을 반복할 수 없는 이유
    
- 문제를 해결하는 방법
    1. Stream의 iterator 메소드에 메소드 참조를 건넨다.
        - 메소드 참조를 매개변수화된 Iterable로 적절히 형변환 필요
        - 난잡하고 직관성이 떨어지는 방법
            ```java
            for (ProcessHandle ph : (Iterablr<ProcessHandle>) ProcessHandle.allProcesses():iterator) {
                // 프로세스 처리
            }
            ```
    2. 어댑터 메소드 사용
        - 따로 형변환 필요 없음
            ```java
            // Stream<E>를 Iterable<E>로 중개해주는 어댑터
            public static <E> Iterable<E> iterableOf(Stream<E> stream) {
                return stream::iterator;
            }

            // ----------------------------------

            for (ProcessHandle ph : iterableOf(ProcessHandle.allProcesses())) {
                // 프로세스 처리
            }
            ```

- 반대로 Iterable만 반환하는 API를 스트림 파이프라인에서 처리하는 방법
    - 어댑터 메소드
        ```java
        // Iterable<E>를 Stream<E>로 중개해주는 어댑터
        public static <E> Stream<E> streamOf(Iterable<E> iterable) {
            return StreamSupport.stream(iterable.spliterator(), flase);
        }
        ```

<br>

- 객체 시퀀스를 반환하는 메소드를 작성할 때 사용자가 한 방식만 사용할 것이라는 근거가 없다면 **반환 타입을 스트림과 컬렉션 모두 만족**하게 하자
    - **원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위 타입을 쓰는 게 일반적으로 최선이다.**
        > Collection 인터페이스는 Iterable의 하위 타입이고 stream 메소드도 제공하므로 반복과 스트림을 동시에 지원
    - **단지 컬렉션을 반환한다는 이유로 덩치 큰 시퀀스를 메모리에 올려서는 안된다.**
        - 반환하는 시퀀스의 크기가 작다면 ArrayList나 HashSet 같은 **표준 컬렉션** 구현체를 반환
        - 시퀀스가 크지만 표현을 간결하게 할 수 있다면 **전용 컬렉션**을 구현

<br>

*만약 나중에 Stream 인터페이스가 Iterable을 지원하도록 자바가 수정된다면, 그때는 안심하고 스트림을 반환하면 될 것이다.*

<br>
<br>

### :label: Item 48 - "스트림 병렬화는 주의해서 적용하라"

- 스트림 병렬화
    - 방법: `parallel` 메소드 호출로 파이프라인을 병렬 실행
    - 동시성 프로그래밍과 같이 안정성(safety)과 응답 가능(liveness) 상태를 유지하기 위해 노력 필요

<br>

- **데이터 소스가 Stream.iterate거나 중간 연산으로 limit을 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.**
    - 스트림 라이브러리가 파이프라인을 병렬화하는 방법을 찾아내지 못할 수 있다.
    - **병렬화의 효과가 가장 좋은 경우:**
        - 스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap의` 인스턴스거나 **배열**, `int` 범위, `long` 범위일 때
            > 공통점: 원소들을 순차적으로 실행할 때의 참조 지역성이 뛰어남

<br>

- **종단 연산 중 병렬화에 가장 적합한 것은 축소이다.**
    - 종단 연산에서 수행하는 작업량이 파이프라인에서 큰 비중을 차지하면서 순차적인 연산이라면 병렬 수행의 효과는 제한적
    - 축소: 파이프라인에서 만들어진 모든 원소를 하나로 합치는 작업
        > Stream의 reduce메소드 중 하나, 혹은 min, max, count, sum
    - 조건에 맞으면 바로 반환되는 메소드도 병렬화에 적합
        > antMatch, allMatch, noneMatch
    - 가변 축소(mutable reduction)의 경우 컬렉션을 합치는 부담이 크므로 병렬화에 적합하지 않음
        > Stream의 collect 메소드

<br>

- 직접 구현한 Stream, Iterable, Collection이 병렬화의 이점을 누리게 하고 싶다면 spliterator 메소드를 재정의하고 결과 스트림의 병렬화 성능을 강도 높게 테스트하라

<br>
    
- **스트림을 잘못 병렬화하면 (응답 불가를 포함해) 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있다.**
    - 안전 실패(sfety failure): 결과가 잘못되거나 오동작하는 것
    - 안전실패는 병렬화한 파이프라인이 사용하는 함수 객체가 명세대로 동작하지 않을 때 발생 가능
    - Stream 명세의 함수 객체에 관한 규약:
        - Stream의 reduce 연산에 건네지는 accumulator(누적기)와 combiner(결합기) 함수는 반드시 결합법칙을 만족하고(associative), 간섭받지 않고(non-interfering), 상태를 갖지 않아야(stateless) 한다.
    
<br>

- **조건이 잘 갖춰지면 parallel 메소드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있다.**
    - 스트림 병렬화는 오직 성능 최적화 수단이다.
    - 다른 최적화와 마찬가지로 변경 전후로 반드시 성능을 테스트하여 병렬화를 사용할 가치가 있는지 확인해야 한다.
    - 잘못된 파이프라인 하나가 시스템의 다른 부분의 성능에도 악영향을 줄 수 있다.
        > 병렬 스트림 파이프라인도 공통의 포크-조인 풀(같은 스레드 풀)에서 수행

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 8장 메서드

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 9장 일반적인 프로그래밍 원칙

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 10장 예외

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 11장 동시성

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>

## 12장 직렬화

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#Effective-Java)  

<br/><br/>
