# 스프링 입문을 위한 자바 객체 지향의 원리와 이해

### :paperclip: Contents
- [1. 사람을 사랑한 기술](#1장-사람을-사랑한-기술)
- [2. 자바와 절차적/구조적 프로그래밍](#2장-자바와-절차적구조적-프로그래밍)
- [3. 자바와 객체 지향](#3장-자바와-객체-지향)
- [4. 자바가 확장한 객체 지향](#4장-자바가-확장한-객체-지향)
- [5. 객체 지향 설계 5원칙 - SOLID](#5장-객체-지향-설계-5원칙---solid)
- [6. 스프링이 사랑한 디자인 패턴](#6장-스프링이-사랑한-디자인-패턴)
- [7. 스프링 삼각형과 설정 정보](#7장-스프링-삼각형과-설정-정보)

---

## 1장 사람을 사랑한 기술

### 기계어에서 객체 지향 프로그래밍 언어로

- **기계어 - 0과 1의 행진 / 너무나 비인간적인 언어**
    - 컴퓨터는 2진법밖에 모르지만 대단히 빠르고 정확하다.
    - 기계어
        - 기계가 이해하는 유일한 언어로, 2진 숫자인 0과 1로만 표현
        - 기계어 코드는 CPU에 따라 다르다. (애드삭 or 유니박)

- **어셈블리어 - 0과 1의 행진을 벗어나 인간 지향으로 / 기계어 니모닉**
    - 어셈블리어
        - **어셈블리**: 기계어 명령어를 일상 용어(니모닉; 어떤 것을 기억하는 데 도움을 주는 것)로 표현하는 매칭 코드표
        - CPU마다 기계어가 다르기 때문에 각각 어셈블리어도 다르다.
        - **어셈블러**: 어셈블리어를 기계어로 번역하는 소프트웨어는 어셈블러
    
- **C언어 - 강력한 이식성 / One Source Multi Object Use Anywhere**
    - 특징:
        - **One source (싱글 소스)**
            - 하나의 C 소스 파일만 작성
            - 기존의 어셈블리어로 개발할 때 프로그램의 소스 파일을 각 기계의 종류만큼 만들어야 했다. (멀티 소스)
            - 하나의 소스 파일을 각 기계에 맞는 컴파일러로 컴파일하면 각 기계에 맞는 기계어 목적 파일이 만들어진다.
        - **Multi Object**
            - 기종마다 하나씩 기계어 목적 파일을 생성
        - **Use Anywhere**
            - 모든 컴퓨터에서 실행 가능
    - 정리:
        - 한계: 운영체제별 특성이 달라 하나의 소스로 컴파일하기 전 그 기종에 맞게 소스를 변경하는 작업 필요
        - 엄밀히 말하면 one source 뒤에 fix source(소스 수정 작업)가 필요하다.
        - 하지만 이식성이 좋아진 것은 진실 (어셈블리어 대비)
        - 인간의 언어 체계가 기계어와 1:1 매칭이 아닌 m:n 매칭이 가능해졌다.

- **C++ - 정말 인간적인 프로그래밍 방법론, 객체 지향**
    - 객체 지향 도입

- **자바 - 진정한 객체 지향 언어**
    - 객체 지향 언어의 중심에는 클래스(또는 객체)가 있다.
    - main 메소드는 클래스 내부에 존재하고, 모든 메소드는 클래스.메소드명() 또는 객체.메소드명()으로 접근해야 한다.
    - C++도 객체 지향 언어지만, 객체 없는 프로그래밍도 가능하다.
        > ex) main함수는 클래스와 별도로 존재 가능.  
        > printf() 함수는 클래스나 객체와 관계없이 호출 가능
    - **가상 머신(virtual machine)**
        - "Write Once Use Anywhere"
        - 컴파일러를 기종별로 따로 구매하지 않아도 된다. 
        - 오브젝트 파일만 있다면 실행 가능 (해당 기종용 JRE는 필요)

<br/>

### 짧은 글, 긴 생각

- **UML**
    - 의사소통의 도구. 표기 방법론.
    - *UML 표기법 하나하나에 목숨 걸지 말자.*
    - 액티비티 다이어그램 보단 순서도나 NS차트(Nassi-Schneiderman chart)
    - 클래스 다이어그램, 시퀀스 다이어그램

- **CBD, SOA**
    - **CBD (Computer Based Develpment)**
        - 컴포넌트 기반 개발
    - **SOA (Service Oriented Architecture)**
        - 서비스 중심/지향 구조
    - *개념은 있으되 제품은 없다*
    - *굳이 신경쓰다가 휘둘리지 말자*

- **스프링 프레임워크는 사상이면서 또 단일 제품이다**
    - 스프링 프레임워크는 **OOP 프레임워크** 중 하나의 제품
    - 객체 지향을 모르고 스프링을 안다는 것은 어불성설
    - 스프링 삼각형(IoC/DI, AOP, PSA)

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 2장 자바와 절차적/구조적 프로그래밍

### 자바 프로그램의 개발과 구동

- 자바의 가상 세계
    - **JDK - 자바 개발 도구** - JVM용 소프트웨어 개발 도구
        - javac.exe 포함 - 자바 소스 컴파일러
    - **JRE - 자바 실행 환경** - JVM용 OS
        - java.exe 포함 - 자바 프로그램 실행기
    - **JVM - 자바 가상 기계** - 가상의 컴퓨터

- 프로그램이 메모리를 사용하는 방식
    - **코드 실행 영역**
    - **데이터 저장 영역**
        - **스태틱(static)**: 클래스들의 놀이터
        - **스택(stack)**: 메소드들의 놀이터
        - **힙(heap)**: 객체들의 놀이터

<br/>

### 자바에 존재하는 절차적/구조적 프로그래밍의 유산
- 절차적 프로그래밍 -> goto: 제어 흐름을 이동시키는 용도 - **사용 금지**
    > 프로그램 실행 순서가 인간이 이해하기에 복잡해질 수 있다.
    - 이외에도 많음
- 구조적 프로그래밍 -> **함수**
    - 중복 코드 관리 & 논리를 함수 단위로 분리하여 이해하기 쉬운 코드
    - 객체 지향에서는 메소드라고 표현 (뜻은 다르지 않다.)
    - 메소드는 반드시 클래스 내부에 존재

<br/>

### 다시 보는 main() 메소드: 메소드 스택 프레임
- main() 메소드는 프로그램이 실행되는 시작점이자 끝.
- main() 메소드 실행 과정
    1. JRE는 프로그램 안에 main() 메소드 존재 유무 확인
    2. main()이 확인 되면 JVM에 전원을 넣어 부팅
    3. JVM은 목적 파일을 받아 실행
        - 전처리: 
            - java.lang 패키지와 import된 패키지를 스태틱 영역에 저장. 
            - 프로그램 상의 모든 클래스를 스태틱 영역에 저장
    4. main() 메소드의 스택 프레임을 스택에 할당 (중괄호 하나마다 생긴다.)
    5. main의 인자 args를 저장할 공간을 스택 프레임의 맨 아래 공간에 할당
    6. main 메소드 안의 첫 명령문 실행
    7. 모든 명령문이 실행되고 닫는 중괄호와 만나면 스택 프레임 소멸 (main 메소드 종료)
    8. JRE는 JVM 종료 & JRE는 운영체제 상의 메모리에서 소멸

<br/>

### 지역 변수와 메모리: 스택 프레임에 갇혔어요!

- 변수는 스태틱, 스택, 힙 영역 모두에 존재한다.
    - **클래스 멤버 변수 (스태틱)**
        - 스태틱 영역에서 일생을 보낸다.
        - JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.
    - **지역 변수 (스택)**
        - 스택 영역의 스택 프레임 안에서 일생을 보낸다.
        - 스택 프레임이 사라지면 함께 사라진다. 
        - 외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.
    - **객체 멤버 변수 (힙)**
        - 힙에서 일생을 보낸다.
        - 객체와 함께 가비지 컬랙터에 의해 일생을 마친다.

<br/>

### 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!
- 표현:
    - 코드 어느 곳에서나 접근할 수 있다고 해서 전역 변수
    - 여러 메소드들이 공유해서 사용한다고 해서 공유 변수

- 쓰지 말아야 하는 이유:
    - 프로젝트 규모가 커지면서(멀티 스레드 등) 여러 메소드에서 전역 변수의 값을 변경하면 메모리를 추적하지 않는 이상 전역 변수의 값을 파악하기 쉽지 않다.

- 다만, 읽기 전용으로 값을 공유해서 **전역 상수**로 쓰는 것은 적극 추천
    > ex) PI 값

<br/>

### 멀티 스레드 / 멀티 프로세스의 이해
- 멀티 스레드
    - 하나의 메모리 안에서 스택 영역을 스레드 개수만큼 분할해서 사용
    - 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만, 스태틱 영역과 힙 영역은 공유해서 사용하는 구조
    - 멀티 프로세스 대비 메모리를 적게 사용하는 구조
- 멀티 프로세스
    - 다수의 데이터 저장 영역을 갖는 구조
    - 각 프로레스마다 각자의 메모리가 있고 고유의 공간이므로 서로 참조가 불가능
    - 메모리 안전한 구조이지만 메모리 사용량은 크다.

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 3장 자바와 객체 지향

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 4장 자바가 확장한 객체 지향

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 5장 객체 지향 설계 5원칙 - SOLID

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 6장 스프링이 사랑한 디자인 패턴

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 7장 스프링 삼각형과 설정 정보

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>
