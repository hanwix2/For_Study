# 스프링 입문을 위한 자바 객체 지향의 원리와 이해

### :paperclip: Contents
- [1. 사람을 사랑한 기술](#1장-사람을-사랑한-기술)
- [2. 자바와 절차적/구조적 프로그래밍](#2장-자바와-절차적구조적-프로그래밍)
- [3. 자바와 객체 지향](#3장-자바와-객체-지향)
- [4. 자바가 확장한 객체 지향](#4장-자바가-확장한-객체-지향)
- [5. 객체 지향 설계 5원칙 - SOLID](#5장-객체-지향-설계-5원칙---solid)
- [6. 스프링이 사랑한 디자인 패턴](#6장-스프링이-사랑한-디자인-패턴)
- [7. 스프링 삼각형과 설정 정보](#7장-스프링-삼각형과-설정-정보)

---

## 1장 사람을 사랑한 기술

### 기계어에서 객체 지향 프로그래밍 언어로

- **기계어 - 0과 1의 행진 / 너무나 비인간적인 언어**
    - 컴퓨터는 2진법밖에 모르지만 대단히 빠르고 정확하다.
    - 기계어
        - 기계가 이해하는 유일한 언어로, 2진 숫자인 0과 1로만 표현
        - 기계어 코드는 CPU에 따라 다르다. (애드삭 or 유니박)

- **어셈블리어 - 0과 1의 행진을 벗어나 인간 지향으로 / 기계어 니모닉**
    - 어셈블리어
        - **어셈블리**: 기계어 명령어를 일상 용어(니모닉; 어떤 것을 기억하는 데 도움을 주는 것)로 표현하는 매칭 코드표
        - CPU마다 기계어가 다르기 때문에 각각 어셈블리어도 다르다.
        - **어셈블러**: 어셈블리어를 기계어로 번역하는 소프트웨어는 어셈블러
    
- **C언어 - 강력한 이식성 / One Source Multi Object Use Anywhere**
    - 특징:
        - **One source (싱글 소스)**
            - 하나의 C 소스 파일만 작성
            - 기존의 어셈블리어로 개발할 때 프로그램의 소스 파일을 각 기계의 종류만큼 만들어야 했다. (멀티 소스)
            - 하나의 소스 파일을 각 기계에 맞는 컴파일러로 컴파일하면 각 기계에 맞는 기계어 목적 파일이 만들어진다.
        - **Multi Object**
            - 기종마다 하나씩 기계어 목적 파일을 생성
        - **Use Anywhere**
            - 모든 컴퓨터에서 실행 가능
    - 정리:
        - 한계: 운영체제별 특성이 달라 하나의 소스로 컴파일하기 전 그 기종에 맞게 소스를 변경하는 작업 필요
        - 엄밀히 말하면 one source 뒤에 fix source(소스 수정 작업)가 필요하다.
        - 하지만 이식성이 좋아진 것은 진실 (어셈블리어 대비)
        - 인간의 언어 체계가 기계어와 1:1 매칭이 아닌 m:n 매칭이 가능해졌다.

- **C++ - 정말 인간적인 프로그래밍 방법론, 객체 지향**
    - 객체 지향 도입

- **자바 - 진정한 객체 지향 언어**
    - 객체 지향 언어의 중심에는 클래스(또는 객체)가 있다.
    - main 메소드는 클래스 내부에 존재하고, 모든 메소드는 클래스.메소드명() 또는 객체.메소드명()으로 접근해야 한다.
    - C++도 객체 지향 언어지만, 객체 없는 프로그래밍도 가능하다.
        > ex) main함수는 클래스와 별도로 존재 가능.  
        > printf() 함수는 클래스나 객체와 관계없이 호출 가능
    - **가상 머신(virtual machine)**
        - "Write Once Use Anywhere"
        - 컴파일러를 기종별로 따로 구매하지 않아도 된다. 
        - 오브젝트 파일만 있다면 실행 가능 (해당 기종용 JRE는 필요)

<br/>

### 짧은 글, 긴 생각

- **UML**
    - 의사소통의 도구. 표기 방법론.
    - *UML 표기법 하나하나에 목숨 걸지 말자.*
    - 액티비티 다이어그램 보단 순서도나 NS차트(Nassi-Schneiderman chart)
    - 클래스 다이어그램, 시퀀스 다이어그램

- **CBD, SOA**
    - **CBD (Computer Based Develpment)**
        - 컴포넌트 기반 개발
    - **SOA (Service Oriented Architecture)**
        - 서비스 중심/지향 구조
    - *개념은 있으되 제품은 없다*
    - *굳이 신경쓰다가 휘둘리지 말자*

- **스프링 프레임워크는 사상이면서 또 단일 제품이다**
    - 스프링 프레임워크는 **OOP 프레임워크** 중 하나의 제품
    - 객체 지향을 모르고 스프링을 안다는 것은 어불성설
    - 스프링 삼각형(IoC/DI, AOP, PSA)

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 2장 자바와 절차적/구조적 프로그래밍

### 자바 프로그램의 개발과 구동

- 자바의 가상 세계
    - **JDK - 자바 개발 도구** - JVM용 소프트웨어 개발 도구
        - javac.exe 포함 - 자바 소스 컴파일러
    - **JRE - 자바 실행 환경** - JVM용 OS
        - java.exe 포함 - 자바 프로그램 실행기
    - **JVM - 자바 가상 기계** - 가상의 컴퓨터

- 프로그램이 메모리를 사용하는 방식
    - **코드 실행 영역**
    - **데이터 저장 영역**
        - **스태틱(static)**: 클래스들의 놀이터
        - **스택(stack)**: 메소드들의 놀이터
        - **힙(heap)**: 객체들의 놀이터

<br/>

### 자바에 존재하는 절차적/구조적 프로그래밍의 유산
- 절차적 프로그래밍 -> goto: 제어 흐름을 이동시키는 용도 - **사용 금지**
    > 프로그램 실행 순서가 인간이 이해하기에 복잡해질 수 있다.
    - 이외에도 많음
- 구조적 프로그래밍 -> **함수**
    - 중복 코드 관리 & 논리를 함수 단위로 분리하여 이해하기 쉬운 코드
    - 객체 지향에서는 메소드라고 표현 (뜻은 다르지 않다.)
    - 메소드는 반드시 클래스 내부에 존재

<br/>

### 다시 보는 main() 메소드: 메소드 스택 프레임
- main() 메소드는 프로그램이 실행되는 시작점이자 끝.
- main() 메소드 실행 과정
    1. JRE는 프로그램 안에 main() 메소드 존재 유무 확인
    2. main()이 확인 되면 JVM에 전원을 넣어 부팅
    3. JVM은 목적 파일을 받아 실행
        - 전처리: 
            - java.lang 패키지와 import된 패키지를 스태틱 영역에 저장. 
            - 프로그램 상의 모든 클래스를 스태틱 영역에 저장
    4. main() 메소드의 스택 프레임을 스택에 할당 (중괄호 하나마다 생긴다.)
    5. main의 인자 args를 저장할 공간을 스택 프레임의 맨 아래 공간에 할당
    6. main 메소드 안의 첫 명령문 실행
    7. 모든 명령문이 실행되고 닫는 중괄호와 만나면 스택 프레임 소멸 (main 메소드 종료)
    8. JRE는 JVM 종료 & JRE는 운영체제 상의 메모리에서 소멸

<br/>

### 지역 변수와 메모리: 스택 프레임에 갇혔어요!

- 변수는 스태틱, 스택, 힙 영역 모두에 존재한다.
    - **클래스 멤버 변수 (스태틱)**
        - 스태틱 영역에서 일생을 보낸다.
        - JVM이 종료될 때까지 고정된(static) 상태로 그 자리를 지킨다.
    - **지역 변수 (스택)**
        - 스택 영역의 스택 프레임 안에서 일생을 보낸다.
        - 스택 프레임이 사라지면 함께 사라진다. 
        - 외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.
    - **객체 멤버 변수 (힙)**
        - 힙에서 일생을 보낸다.
        - 객체와 함께 가비지 컬랙터에 의해 일생을 마친다.

<br/>

### 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!
- 표현:
    - 코드 어느 곳에서나 접근할 수 있다고 해서 전역 변수
    - 여러 메소드들이 공유해서 사용한다고 해서 공유 변수

- 쓰지 말아야 하는 이유:
    - 프로젝트 규모가 커지면서(멀티 스레드 등) 여러 메소드에서 전역 변수의 값을 변경하면 메모리를 추적하지 않는 이상 전역 변수의 값을 파악하기 쉽지 않다.

- 다만, 읽기 전용으로 값을 공유해서 **전역 상수**로 쓰는 것은 적극 추천
    > ex) PI 값

<br/>

### 멀티 스레드 / 멀티 프로세스의 이해

- **멀티 스레드**
    - 하나의 메모리 안에서 스택 영역을 스레드 개수만큼 분할해서 사용
    - 하나의 스레드에서 다른 스레드의 스택 영역에는 접근할 수 없지만, 스태틱 영역과 힙 영역은 공유해서 사용하는 구조
    - 멀티 프로세스 대비 메모리를 적게 사용하는 구조
- **멀티 프로세스**
    - 다수의 데이터 저장 영역을 갖는 구조
    - 각 프로레스마다 각자의 메모리가 있고 고유의 공간이므로 서로 참조가 불가능
    - 메모리 안전한 구조이지만 메모리 사용량은 크다.

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 3장 자바와 객체 지향

### 객체 지향은 인간 지향이다

- 인간 지향
    - "현실 세계처럼 프로그래밍할 수 없을까?" -> **객체**
    - 우주 만물은 객체들의 합이다. (보이는 것, 만져지는 것, 상상하는 모든 것)
    - 기계에 맞춰 사고하던 방식을 버리고 현실세계를 인지하는 방식으로 프로그램을 만들자는 것
    - 객체 지향은 직관적이다

- **객체(object)**
    - 세상에 존재하는 모든 것은 사물, 즉 객체이다.
    - 각각의 사물은 고유하다.
    - 사물은 속성(property)을 갖는다.
    - 사물은 행위(method)를 한다.

- **분류(class)** 
    - 사물을 하나하나 이해하기 보단 사물을 분류
    - 분류 예시:
        - 직립보행을 하며 말을 하는 존재를 사람이라고 분류
        - 연미복, 짧은 다리, 날지 못하는 새를 펭귄이라고 분류
        - 밤하늘에 반짝이는 사물을 별이라고 분류

- 기존의 프로그래밍
    - 속성과 메소드를 객체라는 단위로 묶지 않고
    - 속성(필드) 따로 메소드(함수) 따로 분리된 형태로 프로그래밍

<br/>

### 객체 지향의 4대 특성 - 캡!상추다

- 캡 - **캡슐화**: 정보 은닉
- 상 - **상속**: 재사용
- 추 - **추상화**: 모델링
- 다 - **다형성**: 사용 편의

<br/>

### 클래스 vs 객체 = 붕어빵틀 vs 붕어빵 ???

- 비교:
    - 클래스 객체명 = new 클래스();
    - 붕어빵틀 붕어방 = new 붕어빵틀();
        - 금형기계 붕어빵틀 = new 금형기계();
        - "새로운 금형기계를 하나 만들었더니 붕어빵틀이 되었다?"
        - 붕어빵틀은 붕어빵을 만들기 위한 팩토리
- 클래스와 객체
    - **클래스는 분류에 대한 개념이지 실체가 아니다.**
    - **객체는 실체다.**
    > 사람과 김연아를 구분할 때, 나이를 물어보자!  
    > 사람의 나이는? 김연아의 나이는?  
    > 여기서 클래스와 객체의 차이가 드러난다.

- 결론: **"클래스와 객체의 관계 - 분류(class)와 사물(Object)의 관계"**

<br/>

### 추상화: 모델링

- 추상: 여러가지 사물이나 개념에서 **공통되는 특성이나 속성 따위를 추출**하여 파악하는 작용

- "객체 지향의 추상화는 곧 모델링이다"
    - 객체: 세상에 조내하는 유일무이한 사물
    - 클래스: 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념
    - 어플리케이션 경계: 내가 만들고자 하는 어플리케이션은 어디에서 사용될 것인가?에 대한 기준
    - **추상화: 구체적인 것을 분해해서 관심 영역(어플리케이션 경계)에 대한 특성만을 가지고 재조합하는 것 = 모델링**
        - 클래스 범위에서의 추상화
            - 클래스 설계에서 추상화가 사용된다.
            - 클래스 설계를 위해서는 어플리케이션 경계부터 정해야 한다.
            - 객체 지향에서 추상화의 결과는 클래스다.
            - **추상화 = 모델링 = 자바의 class 키워드**
        - 더 넓은 범위에서의 추상화
            - 상속을 통한 추상화, 구체화
            - 인터페이스를 통한 추상화
            - 다형성을 통한 추상화

- 추상화
    - 추상화는 주관적
    - 추상화의 결과물은 모델
    - 모델은 자바에서 클래스로 표현
    - 클래스 모델을 표현하는 국제 표준 표기법은 UML 클래스 다이어그램

<br/>

### 상속: 재사용 + 확장

- 객체 지향에서의 상속
    - 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미
    - 클래스를 상속한다는 말 보단 **클래스의 특성**을 상속한다고 알자!
    - 객체 지향의 상속은 부모-자식 같은 계층도나 조직도가 아닌 동물-포유류 같은 **분류도**이다!
    - 따라서 부모-자식 관계 보다는 **상위 클래스 - 하위 클래스**라고 표현하자
    - 상위 클래스 쪽으로 갈수록 추상화, 일반화됐다고 말하며, 하위 클래스 쪽으로 갈수록 구체화, 특수화됐다고 말한다.
    
    > "하위 클래스는 상위 클래스다." -> "LSP(리스코프 치환 원칙)"  
    > ex1) 포유류는 동물이다.  
    > ex2) 아들은 아버지다?? - 이건 좀 이상하다.

- 상속의 영어 표현
    - Inheritance 보단 **extends**

- 상속 관계의 표현
    - 'is a' 보단 **'is a kind of'**

- **상속 정리**
    - 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
    - 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
    - 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

- 다중 상속
    - '다이아몬드 문제' 발생 가능
    - 대신 자바에서는 인터페이스 도입 (상속과는 다른 개념)

- **인터페이스**
    - "무엇을 할 수 있는"이라는 표현 형태로 만드는 것이 좋다.
    - 구현 클래스 is able to 인터페이스

<br/>

### 다형성: 사용편의성

- **오버라이딩**: 같은 메소드명, 같은 인자 목록으로 상위 클래스의 메소드를 재정의
    - 하위 클래스가 재정의한 메소드를 알아서 호출해 줌으로써 형변환이나 instanceof 연산자를 써서 하위 클래스가 무엇인지 신경 쓰지 않아도 된다.
    - 상위 클래스 타입의 객체 참조 변수에서 하위 클래스가 오버라이딩한 메소드를 자동으로 호출함으로 깔끔한 코드 유지 가능

<br/>

- **오버로딩**: 같은 메소드명, 다른 인자 목록으로 다수의 메소드를 중복 정의
    - 함수명 하나를 가지고 인자 목록만 달리하여 비슷한 기능을 수행할 수 있어 편리하다.
    - 제네릭을 이용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다.

<br/>

### 캡슐화: 정보 은닉

    객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 감추어 은닉한다.

- 객체 멤버의 접근 제어자
    - 상속을 받지 않았다면 객체 멤버는 객체를 상성한 후 객체 참조 변수를 이용해 접근해야 한다.
    - 정적 멤버는 '클래스명.정적멤버' 형식으로 접근하는 것을 권장한다. 
        - 메모리의 물리적 접근 방법에 따른 이득 존재
        > ex. 고양이.다리수  
        > 키티.다리수 같은 '객체참조변수명.정적멤버' 형식은 지양
        
- 참조 변수의 복사
    - **Call By Reference** 또는 **Call By Address**
        > 참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다.
    - 기본 자료형 변수를 복사하는 경우는 Call By Value
        > 기본 자료형 변수는 값을 값 자체로 판단한다.

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 4장 자바가 확장한 객체 지향

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 5장 객체 지향 설계 5원칙 - SOLID

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 6장 스프링이 사랑한 디자인 패턴

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>

## 7장 스프링 삼각형과 설정 정보

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#스프링-입문을-위한-자바-객체-지향의-원리와-이해)  

<br/><br/>
