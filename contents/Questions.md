# Questions

### :paperclip: Contents
1. [JAVA](#label-java)
2. [Web](#label-web)
3. [Spring](#label-spring)
4. [MySql](#label-mysql)
5. [Data Structure](#label-data-structure)
6. [Network](#label-network)
7. [DevOps](#label-devops)
8. [ETC](#label-etc)

---

## :label: Java

### Q. 객체지향 프로그래밍이란?
*철학적 관점. 쉽게 자신만의 설명 필요*

### Q. 객체지향의 원칙은?
객체지향 4대 원칙 - “캡상추다”
- **캡슐화**(정보은닉)
- **상속**(재사용 + 확장)
- **추상화**(모델링) - 공통적인 특성을 추출 / 구체적인 것을 분해하여 관심있는 특성만 재조합
- **다형성**(사용 편의) - 오버라이딩과 오버로딩

### Q. 객체 지향적 설계 원칙은?
SOLID // “응집도는 높이고 결합도는 낮춘다.”
- SRP(Singel Resposibility principle): **단일 책임 원칙** 
    - 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- OCP(Open-Closed principle): **개방 폐쇄 원칙** 
    - 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다. 
- LSP(Liskov Substitution principle): **리스코프 치환 원칙** 
    - 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.
- ISP(Interface Segregation principle): **인터페이스 분리 원칙** 
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다. (인터페이스는 그 역할에 충실한 최소한의 기능만 공개하라)
- DIP(Dependency Inversion principle): **의존 역전 원칙**
    - 자신보다 변하기 쉬운 것에 의존하지 마라
    - 상위 클래스, 인터페이스, 추상 클래스일수록 변하지 않을 가능성이 높다.

### Q. 단일 책임 원칙이란?
- 한 클래스는 한 책임을 가져야 한다. / 하나의 기능당 하나씩 코드를 만들고 필요한 곳에서 골라서 쓸 수 있다.
- 여러 기능이 포함되어 있으면 다른 곳 적용에 한계가 있다.
- 적용했을 때의 장점 - 재사용성이 높아지고 유지보수성이 높아진다.

### Q. 개방 폐쇄의 원칙이란?
- **개방 측면** - 새로운 기능 추가 / 인터페이스 의존(느슨한 결합), 상속, 다형성
- **폐쇄 측면** - 의존 관계에서 다른 기능의 변경이 있을 때 갈아 끼우기만 하고 자신의 코드는 수정을 최소화

### Q. 오버로딩과 오버라이딩의 차이?
- **오버로딩**: (*확장*) 메소드의 이름은 같게 하고 매개 변수를 다르게 함. 매개 변수의 확장
- **오버라이딩**: (*덮어씀*) 부모 클래스의 메소드 시그니처를 복제해서 재정의

### Q. 다형성의 장점
- 유지보수성
- 하나의 부모 클래스 상속. 
- 형변환. 갈아 끼울 수 있다.

### Q. Static을 사용할 때 주의점
- GC가 static은 안 쓰는 메모리라고 판단하지 못한다.
- 상수가 아닐 경우, 다른 사람이 사용했을 때(또는 여러 스레드) 값의 변경 가능성이 있어 의도치 않은 문제가 발생할 수 있다. (캡슐화/정보은닉 실패)
- 무조건 final을 사용할 순 없다. (계산 값이 아닌 상태 값으로 사용할 수도 있음)

### Q. inner class 와 static inner class의 차이
- **Static inner class**: 한 곳에서만 사용되는 클래스를 논리적으로 묶어서 처리할 때 / 외부 참조 없음
- **Inner class**: 내부에서만 사용하고 그 구현을 감추고 싶을 때 (캡슐화) / 숨은 외부 참조
- 숨은 외부 참조의 문제 
    – GC 대상이 아니라 메모리 누수 가능
    - Static을 사용하고 싶지 않으면 별도의 클래스로 만들길

### Q. final을 사용하는 이유?
- 값이 바뀌지 않는 것 보장
- 유지보수 측면에서 유용: 다른 사람과 공유 – 내부적인 기능 변경 X
- Thread safe (immutable)

### Q. finally란?
- try 내에서 return 되어도 상관없이 무조건 실행된다.
    - 통신 같이 자원 할당 해제 시 (finally에서 무조건 close 실행)

### Q. 어노테이션이란?
- 사전적 의미로는 주석이지만, 일반 주석과는 달리 컴파일 되어 특별한 의미를 나타내거나, 기능을 수행하도록 한다. 
- **메타데이터**: 추가적인 정보 제공
- 사용:
    - 컴파일러에게 정보를 알려주거나
    - 컴파일할 때와 설치시의 작업을 지정하거나
    - 실행할 때와 별도의 처리가 필요할 때

### Q. Enum이란?
- 상수의 집합 (열거타입)
- 무조건 값이 있으란 법은 없다. (일반 상수와 차이점)
- 값 지정도 가능
- 장점: 표현력이 좋고 컴파일 타임에 타입 안정성을 보장한다.

### Q. String 연산이 비효율적인 이유? 
- 새로운 String 객체를 생성하고 이전 객체는 GC 대상이 된다.
- 왜 새로운 객체를 생성할까? 
    - String은 immutable한 객체 = 한 번 만들면 바꿀 수 없다.
- JDK 1.5 이후 컴파일러에서 알아서 String 연산과 StringBuilder를 적절히 사용한다.
    - 하지만 여러 줄에 걸쳐 String 연산이 이루어진다면 컴파일러에서 StringBuilder를 사용한다 해도 String으로 변환되는 연산이 수행되므로 String 연산에 주의가 필요하다.

### Q. StringBuffer VS StringBuilder
- String 연산 대안
- **StringBuffer**(thread safe) / **StringBuilder**(thread unsafe)
- 객체를 새로 생성하지 않고 기존의 객체의 크기를 증가시키면서 값을 더한다.

### Q. 제네릭이란?
- 자바에는 여러 타입이 존재하는데, 형 변환을 하면서 많은 예외가 발생할 수 있다.
- 제네릭을 사용하면 **컴파일하는 시점**에 **형 변환의 오류**를 찾을 수 있다. (타입 체크)
- 객체의 **타입 안정성**이 높아지고 **형변환의 번거로움을 줄여**준다.
- 클래스에 어떤 타입이 들어가는지 명확히 알 수 있다.
- 유지보수 측면: 어떤 타입인지 알 수 있다. -> 다른 사람이 명확히 알기 쉽다.
- 자바는 정적 타입 언어 -> 변수 타입이 정해져 있다.
- ‘와일드카드’ 

### Q. BigDecimal을 사용하는 이유?
- 기본 타입을 사용하면 부동 소수점 오류 발생

### Q. Synchronized 사용 시 어떤 일 발생?
- 스레드 대기
- **Thread safe** – 다중 스레드 환경에서 공유된 자원 사용 중 예측한 값을 보장할 수 있다.

### Q. Synchronized 동작 방식은?
- 자바 내부적인 스케줄링(lock)
- Lock	
    1. 객체 단위로 lock
    2. 락이 필요한 부분(메소드 or 블록) “연산의 단일성”
- 메소드 or 블록 단위 락은 세밀화 단위만 다를 뿐 기능적 차이는 없다.
- 대규모 트래픽 상황에서 여러 서버 운용도 있을 수 있다. -> 동시성 적용 필요
- 어떤 문제에선 여러 서버에서 일괄적으로 작업하면 비효율적일 때도 있다.

### Q. IO와 NIO의 차이는?
*CPU 자원 낭비 차원 / 각각의 장단점*

|                       | IO        | NIO |
|  :---:                | :---:     |   :---:  |
| 입출력 방식           |  스트림 방식 (단방향 입출력) | 채널 방식 (양방향 입출력 가능)  |
| 버퍼 방식             |  Non-Buffer |  Buffer |
| 비동기 방식           | 지원 X  |  지원 O |
| Blocking  <br> /Non-Blocking |  Blocking 방식만 지원 |  Blocking/Non-Blocking 둘 다 지원 |
- **입출력 방식**
    - 스트림은 입력된 전체 데이터를 별도로 저장하지 않으면 데이터의 위치를 자유롭게 이용할 수 없다.
    - 버퍼를 사용하면 한번에 복수 개의 byte를 입력 받아 출력
        > 성능이 우수 / 데이터의 위치를 이동해가며 필요한 부분만 읽고 쓸 수 있음
- **Blocking**
    - **IO** 입력/출력 스트림에서 데이터가 입력/출력될 때까지 스레드는 Blocking 되고 다른 일을 수행할 수 없음. 블로킹을 빠져나오기 위해 인터럽트 할 수도 없음. (유일한 방법은 스트림을 닫는 것) 그리고 과도한 스레드 생성 가능성 - context switching 비용 증가
    - **NIO** blocking은 인터럽트 함으로 빠져나올 수 있다. 그리고 non-blocking의 경우 입출력 작업 준비가 완료된 채널만 선택해서 작업 스레드가 처리하므로 작업 스레드가 blocking되지 않는다. (Selector는 하나의 스레드가 다수의 channel을 관리할 수 있게 해준다.)
- **결론:**
    - NIO는 non-blocking이나 비동기방식으로 처리할 수 있어 과도한 스레드 생성을 피하고 스레드를 효과적으로 재사용할 수 있다. **NIO는 연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 작업**에 사용하는 것이 좋다. 스레드에서 입출력 처리가 오래 걸린다면 대기하는 작업 수가 늘어나기 때문에 제한된 스레드로 처리하기 불편할 수 있다.
    - 반면, **대용량 데이터 처리의 경우** IO가 좋을 수 있다. NIO의 버퍼 할당 크기가 문제가 될 수 있으므로 연결 클라이언트 수가 적고 전송되는 데이터가 대용량이면서 순차적으로 처리할 필요성이 있다면 IO로 구현하는 것도 방법.

### Q. 자바 8에서 바뀐 점
*람다, 스트림 (함수형, 반응형 프로그래밍과 엮어도 좋다.)*
- **람다 표현식**: 함수형 프로그래밍
    - 메소드를 하나의 식으로 표현
    - 식별자 없이 실행할 수 있는 함수 표현식(익명 함수)
    - 클래스를 만들고 객체를 생성하지 않아도 메소드 사용가능
    - 기존의 불필요한 코드를 줄여주고, 가독성을 높인다.
- **스트림 API**: 데이터의 추상화
    - **기존**
        - 배열이나 컬렉션을 사용하고 데이터에 접근하기 위해 반복문이나 iterator 사용
        - 코드 길이가 길고 가독성이 떨어짐 / 코드의 재사용 불가 / 데이터마다 다른 방법으로 접근
    - **스트림**
        - 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법 제공
        - 외부 반복이 아닌 내부 반복을 통해 작업 수행
        - 원본 데이터를 변경하지 않는다.
        - Filter - map 기반 API 사용. 지연 연산으로 성능 최적화
        - 병렬 처리 지원

### Q. Null을 반환하지 말라는 이유?
- NullException 발생 가능성 존재
- Null을 확인하느라 바쁜 코드 & 가시성이 떨어지고 실수 유발 가능성
- 해결: Null 대신 특수한 목적의 객체 반환 / Collection의 경우 빈 객체 전달
    > **Optional** (java 8) – 선택형 값을 캡슐화 / null 레퍼런스 대신 값이 없는 상황 표현 가능 / null 확인을 위한 복잡한 코드 불필요

### Q. 싱글턴 패턴이란?
- 멀티 스레드 상황에서 synchronized 해주어야 하나의 객체가 보장된다
- 하지만 여러 곳에서 객체를 받을 때 synchronized로 인해 속도가 느리다는 한계
- 싱글턴을 생성하는 방법?
    - **double check lock** 
        - 객체를 만들어야 하는지 먼저 확인 후 객체를 만들어야 할 때만 락
        - 문제점: 여러 스레드에서 운이 나쁘면 여러 인스턴스를 생성할 수 있다.
    - **LazyHolder** 
        – 내부 클래스를 두고 해당 클래스의 인스턴스를 호출할 때 클래스를 로드하여 초기화 한다. 로딩 시점은 thread-safe하고 성능도 좋다.

### Q. 싱글턴 패턴 VS static / 결국 객체를 하나만 사용하는 효과는 동일한데 무슨 차이?
- **싱글턴:** 
    - 사용자 요청 시 하나의 인스턴스를 생성해 재사용. 초기화 시점 조절이 가능 (아예 초기화 안 할 수도)
    - 인터페이스 구현 가능 (확장, 오버라이딩 가능)
    - 싱글턴은 OOP 원칙 준수 가능
- **Static:** 	
    - 인스턴스를 만들 수 없고, 생성자도 갖지 않는다. 처음 로드될 때 초기화
	- 인터페이스 구현 불가능
	- Static 메소드는 인스턴스 변수를 사용할 수 없다.
- 싱글턴을 사용하는 경우 - 로깅, 캐싱, DB 커넥션풀, 카메라, 센서 등
- static을 사용하는 경우 - single-instance, global 데이터를 저장하여 사용하는 용도
	
### Q. immutable이란?
- 변경되지 않음
- Thread safe – 바뀌지 않는 값은 다중 스레드 상황에서도 예상된 결과를 반환
- 유지보수 관점에서 객체를 넘겨서 사용할 때 값이 변경된다면 문제가 발생할 수 있다.
- 다른 곳에서 사용할 땐 복사해서 넘겨주는 것이 좋다. (방어적 복사) 읽기와 쓰기는 분류해서 사용하는 게 좋다. 

### Q. 예외의 종류와 차이는?
- **Checked exception**: 컴파일시 발생하는 예외 / 복구 가능 / 보통 Exception을 확장한 클래스
- **Unchecked exception**(runtime exception): 런타임에 발생하는 예외 / 복구 불가능 / API 명세에 기록된 제약을 지키지 못했을 때
- **Error**: 자바 프로그램 밖에서 발생한 예외 / ex. 디스크, 메인보드 고장

### Q. 언체크 예외를 캐치하는 이유?
- 컴파일은 잘 되지만
- 예외가 발생했을 때 해당 클래스를 호출하는 다른 클래스에서 예외를 처리하도록 구조적 안전장치

### Q. 예외 처리 방법?
*복구, 회피, 전환*
- **복구** 
    - try-catch문에서 복구할 수 있는 것을 복구한다.
    - ex. 커넥션
- **회피**
    - 내 책임이 아닐 때 
    - ex. 쿼리문을 잘못 적은 것은 메소드를 만든 사람의 문제가 아니라 메소드를 가져다 쓰는 사용자의 잘못 -> 사용한 사람이 처리
- **전환** 
    - 다른 layer에서 이해할 수 있는 예외로 translation
    - ex. SQLException은 사용자들이 이해하지 못하므로 “데이터를 가져오지 못했습니다”라고 표현

### Q. (트랜잭션) 특정 예외는 롤백(복구)이 안된다. 어떤 것?
- 체크 예외는 복구를 요구하는 것
- 중복 복구가 되므로 롤백 처리를 하지 않는다.

### Q. 반복문에서 i++ VS ++i 무엇이 더 빠를까?
- 자바 컴파일러가 자동으로 바꿔준다. (그러므로 똑같다.)
- 바이트코드에서 실행순서의 차이 (++i 가 더 빠르긴 함)

### Q. static을 잘못 썼을 때 생기는 문제점?
- 가변적인 변수이면 예상한 결과가 나오지 않을 수 있다.
- 메모리 릭(사용가능한 메모리 부족) 가능성
    > static으로 선언한 부분은 GC가 되지 않는다.

### Q. 메소드에 synchronized가 걸리면 어느 부분에 락이 걸릴까?
메소드에 들어가는 모든 객체에 락 / 객체 단위로 락

### Q. I/O가 일어날 때 스레드에서 일어나는 일?
- Blocking
- 왜 block 할 수밖에 없나?
    - Stream을 이용한 단방향 통신
    - 운영체제 대기 큐에 들어가면서 요청에 대한 system call이 완료된 후에 응답을 보낸다.
> 블로킹과 Sync: https://musma.github.io/2019/04/17/blocking-and-synchronous.html

### Q. NIO는 왜 Block 시키지 않을까?
- Channel을 이용한 양방향 통신 – 읽기, 쓰기를 하나의 통로로(buffer 사용)
- 비동기 방식 지원 – 운영체제 대기 큐에 들어가지 않고 실행 여부와 관계없이 바로 응답을 보낸다.
- non-blocking
    - 클라이언트들은 각각의 채널 할당
    - 셀렉터: 순차적으로 핸들러에 동작 실행 
    - 핸들러: IO 작업을 단일 스레드로 처리 가능

### Q. System.out.println을 쓰지 말아야 하는 이유?
- 커널 CPU를 많이 점유하기 때문에 성능이 떨어진다.
    - 완전히 출력되거나 저장될 때까지 대기
- Stream I/O & Synchronized 사용 – 오버헤드 발생
- 동기화, IO blocking – 병목 발생
- Logger -> 별도의 스레드로 출력
> https://mygumi.tistory.com/83

### Q. 로거의 내부 구조는 어떻게 되어있길래 로그 찍는 속도가 빠를까?
> https://lob-dev.tistory.com/entry/Logging-slf4j-Logback-Framework

### Q. Auto-Closeable 이란?
- 실수로 자원 반납을 하지 않는 것 방지
- Try-with-resources
    - try에서 선언된 객체들을 try가 종료될 때 자동으로 자원 반납
    - 해당 객체는 AutoCloseable을 구현해야 함 (try 구문이 종료될 때 자동으로 close() 메소드 호출)
    - 보통 finally에서 자원 반납을 하였는데 autoCloseable을 사용하면 명시적으로 호출해 줄 필요 없음
    - But, 객체는 try 구문 안에서만 사용가능

### Q. JVM이란?
- Java가 OS에 구애받지 않고 실행할 수 있게 해 줌
- 스택 기반의 가상머신
- 메모리관리, GC 수행
- 구성: 클래스 로더 / 실행 엔진 / 인터프리터 / JIT / 가비지 컬렉터

### Q. JIT optimizer / JIT compiler 란?
- “Just in Time”, “동적 변환” 
- 프로그램 실행을 보다 빠르게 함
- 컴퓨터 프로그램 실행 방식:
	1. **인터프리트 방식**: 프로그램을 실행할 때마다 컴파일. 간편하지만 느림
	2. **정적 컴파일 방식**: 실행하기 전 컴파일을 한 번만 수행
- JIT 컴파일러는 위 두가지 방식을 혼합한 것
    - 변환작업은 인터프리터에 의해 지속적으로 수행되지만, 필요한 코드의 정보는 캐시(메모리)에 담아 두었다가 재사용 한다.
- optimizer: 소스코드를 바이트코드로 된 class 파일로 변환 (javac)
- compiler: 런타임시 바이트코드를 CPU로 직접 보낼 수 있는 명령어(시스템코드)로 변환
javac로 컴파일하는 것은 그저 어떤 OS에서도 수행될 수 있는 바이트 코드 파일로 만드는 것.
- 프로그램이 실행되기 위해선 바이트 코드를 컴퓨터가 알아들을 수 있도록 변환해야 한다. 이것을 JIT 컴파일러가 수행한다.

### Q. 자바 코드 로딩 절차는?
1. java 파일을 컴파일하여 바이트 코드인 class 파일로 변환.
2. class loader가 런타임시에 class 파일을 JVM에 로딩
3. JVM – JIT 컴파일러 …

### Q. GC 과정은?
- GC: 동적으로 할당한 메모리(힙) 영역 중 사용하지 않는 객체를 탐지하여 해제하는 기능
- 구조:
    - 힙은 Young 영역과 Old 영역, Permanent 영역으로 나눠 짐
    - Young 영역은 또 Eden과 Survival1,2로 나눠 짐
    - Permanent 영역은 클래스나 메소드 정보 저장
- “Concurrent Mark and Sweep”
    - 가비지 컬렉터가 stack의 모든 변수를 스캔하면서 각각 어떤 객체를 참조하는지 찾아서 마킹
    - Reachable Object가 참조하고 있는 객체도 찾아서 마킹
    - 마킹되지 않은 객체를 Heap에서 제거
- Minor GC: 
    - 새로 만들어진 객체는 Eden 영역에 위치
    - Eden 영역이 차면 살아있는 객체만 survival 영역으로 객체가 복사되고(GC) 다시 eden 영역을 채운다.
    - Survival 영역이 차면 또 다른 survival 영역으로 객체가 복사(GC). 이 과정을 반복 (하나의 survival 영역은 무조건 비어 있어야 한다.)
- Full GC/Major GC 
    - Minor GC를 수행하며 survival 영역의 객체의 age를 주기마다 증가시키고, 일정 값이 되면 old 영역으로 이동한다.
    - Old 영역이 차면 GC 수행

### Q. major GC가 일어나면 어떤 끔찍한 일이 벌어질까?
- GC를 수행하기 위해 JVM이 멈춤
- “Stop the world” – 성능 저하

### Q. 병렬 콜렉터 / 병령 콤팩팅 콜렉터
- 공통점: GC를 수행하는 스레드가 여러 개. 빠르게 GC 처리 가능 (코어 수가 많을 때 유리)
- 차이점: 콤팩팅(객체 삭제 후 한 곳으로 모으는 작업) 수행 여부

### Q. CMS GC 와 G1 GC 의 차이?
- **CMS** (old 영역의 GC가 다름)
    - 초기 마킹 단계에서 짧은 대기시간으로 클래스 로더에서 가장 가까운 살아있는 객체만 찾는다.
    - 이후 concurrent 마킹 단계에서 위의 살아있는 객체에서 참조하는 객체를 따라가며 확인(별도의 스레드)
    - “stop the world”시간이 짧다.
    - 콤팩팅을 하지 않는다. / cpu를 많이 사용한다.
- **G1**
    - 바둑판 식으로 객체 할당 (young 영역과 old 영역이 물리적으로 나눠져 있지 않음)
    - GC 정지 시간을 최소화 (concurrent)
    - 큰 메모리, 멀티 프로세서 시스템에서 사용
    - 가장 빠른 GC 방법

### Q. JMX란?
- Java Management Extensions
- 자바 모니터링 API
- 실행중인 애플리케이션의 상태 모니터링 하고 설정을 변경할 수 있게 해주는 API
- 성능 테스트
> 'jconsole', 'java mission control', 'java flight recoder', 'jvisualvm'

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: Web

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: Spring

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  


---

## :label: MySQL

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  


---

## :label: Data Structure

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  


---

## :label: Network

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  


---

## :label: DevOps

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: ETC

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  
