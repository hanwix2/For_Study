# Questions

### :paperclip: Contents
1. [JAVA](#label-java)
2. [Web](#label-web)
3. [Spring](#label-spring)
4. [MySql](#label-mysql)
5. [Data Structure](#label-data-structure)
6. [Network](#label-network)
7. [Operating System](#label-operating-system)
8. [DevOps](#label-devops)
9. [ETC](#label-etc)

---

## :label: Java

### 🎯 객체지향 프로그래밍이란?
*철학적 관점. 쉽게 자신만의 설명 필요*

### 🎯 객체지향의 원칙은?
객체지향 4대 원칙 - “캡상추다”
- **캡슐화**(정보은닉)
- **상속**(재사용 + 확장)
- **추상화**(모델링) - 공통적인 특성을 추출 / 구체적인 것을 분해하여 관심있는 특성만 재조합
- **다형성**(사용 편의) - 오버라이딩과 오버로딩

### 🎯 객체 지향적 설계 원칙은?
SOLID // “응집도는 높이고 결합도는 낮춘다.”
- SRP(Singel Resposibility principle): **단일 책임 원칙** 
    - 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
- OCP(Open-Closed principle): **개방 폐쇄 원칙** 
    - 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다. 
- LSP(Liskov Substitution principle): **리스코프 치환 원칙** 
    - 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.
- ISP(Interface Segregation principle): **인터페이스 분리 원칙** 
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다. (인터페이스는 그 역할에 충실한 최소한의 기능만 공개하라)
- DIP(Dependency Inversion principle): **의존 역전 원칙**
    - 자신보다 변하기 쉬운 것에 의존하지 마라
    - 상위 클래스, 인터페이스, 추상 클래스일수록 변하지 않을 가능성이 높다.

### 🎯 단일 책임 원칙이란?
- 한 클래스는 한 책임을 가져야 한다. / 하나의 기능당 하나씩 코드를 만들고 필요한 곳에서 골라서 쓸 수 있다.
- 여러 기능이 포함되어 있으면 다른 곳 적용에 한계가 있다.
- 적용했을 때의 장점 - 재사용성이 높아지고 유지보수성이 높아진다.

### 🎯 개방 폐쇄의 원칙이란?
- **개방 측면** - 새로운 기능 추가 / 인터페이스 의존(느슨한 결합), 상속, 다형성
- **폐쇄 측면** - 의존 관계에서 다른 기능의 변경이 있을 때 갈아 끼우기만 하고 자신의 코드는 수정을 최소화

### 🎯 오버로딩과 오버라이딩의 차이?
- **오버로딩**: (*확장*) 메소드의 이름은 같게 하고 매개 변수를 다르게 함. 매개 변수의 확장
- **오버라이딩**: (*덮어씀*) 부모 클래스의 메소드 시그니처를 복제해서 재정의

### 🎯 다형성의 장점
- 유지보수성
- 하나의 부모 클래스 상속. 
- 형변환. 갈아 끼울 수 있다.

### 🎯 Static을 사용할 때 주의점
- GC가 static은 안 쓰는 메모리라고 판단하지 못한다.
- 상수가 아닐 경우, 다른 사람이 사용했을 때(또는 여러 스레드) 값의 변경 가능성이 있어 의도치 않은 문제가 발생할 수 있다. (캡슐화/정보은닉 실패)
- 무조건 final을 사용할 순 없다. (계산 값이 아닌 상태 값으로 사용할 수도 있음)

### 🎯 inner class 와 static inner class의 차이
- **Static inner class**: 한 곳에서만 사용되는 클래스를 논리적으로 묶어서 처리할 때 / 외부 참조 없음
- **Inner class**: 내부에서만 사용하고 그 구현을 감추고 싶을 때 (캡슐화) / 숨은 외부 참조
- 숨은 외부 참조의 문제 
    – GC 대상이 아니라 메모리 누수 가능
    - Static을 사용하고 싶지 않으면 별도의 클래스로 만들길

### 🎯 final을 사용하는 이유?
- 값이 바뀌지 않는 것 보장
- 유지보수 측면에서 유용: 다른 사람과 공유 – 내부적인 기능 변경 X
- Thread safe (immutable)

### 🎯 finally란?
- try 내에서 return 되어도 상관없이 무조건 실행된다.
    - 통신 같이 자원 할당 해제 시 (finally에서 무조건 close 실행)

### 🎯 어노테이션이란?
- 사전적 의미로는 주석이지만, 일반 주석과는 달리 컴파일 되어 특별한 의미를 나타내거나, 기능을 수행하도록 한다. 
- **메타데이터**: 추가적인 정보 제공
- 사용:
    - 컴파일러에게 정보를 알려주거나
    - 컴파일할 때와 설치시의 작업을 지정하거나
    - 실행할 때와 별도의 처리가 필요할 때

### 🎯 Enum이란?
- 상수의 집합 (열거타입)
- 무조건 값이 있으란 법은 없다. (일반 상수와 차이점)
- 값 지정도 가능
- 장점: 표현력이 좋고 컴파일 타임에 타입 안정성을 보장한다.

### 🎯 String 연산이 비효율적인 이유? 
- 새로운 String 객체를 생성하고 이전 객체는 GC 대상이 된다.
- 왜 새로운 객체를 생성할까? 
    - String은 immutable한 객체 = 한 번 만들면 바꿀 수 없다.
- JDK 1.5 이후 컴파일러에서 알아서 String 연산과 StringBuilder를 적절히 사용한다.
    - 하지만 여러 줄에 걸쳐 String 연산이 이루어진다면 컴파일러에서 StringBuilder를 사용한다 해도 String으로 변환되는 연산이 수행되므로 String 연산에 주의가 필요하다.

### 🎯 StringBuffer VS StringBuilder
- String 연산 대안
- **StringBuffer**(thread safe) / **StringBuilder**(thread unsafe)
- 객체를 새로 생성하지 않고 기존의 객체의 크기를 증가시키면서 값을 더한다.

### 🎯 제네릭이란?
- 자바에는 여러 타입이 존재하는데, 형 변환을 하면서 많은 예외가 발생할 수 있다.
- 제네릭을 사용하면 **컴파일하는 시점**에 **형 변환의 오류**를 찾을 수 있다. (타입 체크)
- 객체의 **타입 안정성**이 높아지고 **형변환의 번거로움을 줄여**준다.
- 클래스에 어떤 타입이 들어가는지 명확히 알 수 있다.
- 유지보수 측면: 어떤 타입인지 알 수 있다. -> 다른 사람이 명확히 알기 쉽다.
- 자바는 정적 타입 언어 -> 변수 타입이 정해져 있다.
- ‘와일드카드’ 

### 🎯 BigDecimal을 사용하는 이유?
- 기본 타입을 사용하면 부동 소수점 오류 발생

### 🎯 Synchronized 사용 시 어떤 일 발생?
- 스레드 대기
- **Thread safe** – 다중 스레드 환경에서 공유된 자원 사용 중 예측한 값을 보장할 수 있다.

### 🎯 Synchronized 동작 방식은?
- 자바 내부적인 스케줄링(lock)
- Lock	
    1. 객체 단위로 lock
    2. 락이 필요한 부분(메소드 or 블록) “연산의 단일성”
- 메소드 or 블록 단위 락은 세밀화 단위만 다를 뿐 기능적 차이는 없다.
- 대규모 트래픽 상황에서 여러 서버 운용도 있을 수 있다. -> 동시성 적용 필요
- 어떤 문제에선 여러 서버에서 일괄적으로 작업하면 비효율적일 때도 있다.

### 🎯 IO와 NIO의 차이는?
*CPU 자원 낭비 차원 / 각각의 장단점*

|                       | IO        | NIO |
|  :---:                | :---:     |   :---:  |
| 입출력 방식           |  스트림 방식 (단방향 입출력) | 채널 방식 (양방향 입출력 가능)  |
| 버퍼 방식             |  Non-Buffer |  Buffer |
| 비동기 방식           | 지원 X  |  지원 O |
| Blocking  <br> /Non-Blocking |  Blocking 방식만 지원 |  Blocking/Non-Blocking 둘 다 지원 |
- **입출력 방식**
    - 스트림은 입력된 전체 데이터를 별도로 저장하지 않으면 데이터의 위치를 자유롭게 이용할 수 없다.
    - 버퍼를 사용하면 한번에 복수 개의 byte를 입력 받아 출력
        > 성능이 우수 / 데이터의 위치를 이동해가며 필요한 부분만 읽고 쓸 수 있음
- **Blocking**
    - **IO** 입력/출력 스트림에서 데이터가 입력/출력될 때까지 스레드는 Blocking 되고 다른 일을 수행할 수 없음. 블로킹을 빠져나오기 위해 인터럽트 할 수도 없음. (유일한 방법은 스트림을 닫는 것) 그리고 과도한 스레드 생성 가능성 - context switching 비용 증가
    - **NIO** blocking은 인터럽트 함으로 빠져나올 수 있다. 그리고 non-blocking의 경우 입출력 작업 준비가 완료된 채널만 선택해서 작업 스레드가 처리하므로 작업 스레드가 blocking되지 않는다. (Selector는 하나의 스레드가 다수의 channel을 관리할 수 있게 해준다.)
- **결론:**
    - NIO는 non-blocking이나 비동기방식으로 처리할 수 있어 과도한 스레드 생성을 피하고 스레드를 효과적으로 재사용할 수 있다. **NIO는 연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 작업**에 사용하는 것이 좋다. 스레드에서 입출력 처리가 오래 걸린다면 대기하는 작업 수가 늘어나기 때문에 제한된 스레드로 처리하기 불편할 수 있다.
    - 반면, **대용량 데이터 처리의 경우** IO가 좋을 수 있다. NIO의 버퍼 할당 크기가 문제가 될 수 있으므로 연결 클라이언트 수가 적고 전송되는 데이터가 대용량이면서 순차적으로 처리할 필요성이 있다면 IO로 구현하는 것도 방법.

### 🎯 자바 8에서 바뀐 점
*람다, 스트림 (함수형, 반응형 프로그래밍과 엮어도 좋다.)*
- **람다 표현식**: 함수형 프로그래밍
    - 메소드를 하나의 식으로 표현
    - 식별자 없이 실행할 수 있는 함수 표현식(익명 함수)
    - 클래스를 만들고 객체를 생성하지 않아도 메소드 사용가능
    - 기존의 불필요한 코드를 줄여주고, 가독성을 높인다.
- **스트림 API**: 데이터의 추상화
    - **기존**
        - 배열이나 컬렉션을 사용하고 데이터에 접근하기 위해 반복문이나 iterator 사용
        - 코드 길이가 길고 가독성이 떨어짐 / 코드의 재사용 불가 / 데이터마다 다른 방법으로 접근
    - **스트림**
        - 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법 제공
        - 외부 반복이 아닌 내부 반복을 통해 작업 수행
        - 원본 데이터를 변경하지 않는다.
        - Filter - map 기반 API 사용. 지연 연산으로 성능 최적화
        - 병렬 처리 지원

### 🎯 Null을 반환하지 말라는 이유?
- NullException 발생 가능성 존재
- Null을 확인하느라 바쁜 코드 & 가시성이 떨어지고 실수 유발 가능성
- 해결: Null 대신 특수한 목적의 객체 반환 / Collection의 경우 빈 객체 전달
    > **Optional** (java 8) – 선택형 값을 캡슐화 / null 레퍼런스 대신 값이 없는 상황 표현 가능 / null 확인을 위한 복잡한 코드 불필요

### 🎯 싱글턴 패턴이란?
- 멀티 스레드 상황에서 synchronized 해주어야 하나의 객체가 보장된다
- 하지만 여러 곳에서 객체를 받을 때 synchronized로 인해 속도가 느리다는 한계
- 싱글턴을 생성하는 방법?
    - **double check lock** 
        - 객체를 만들어야 하는지 먼저 확인 후 객체를 만들어야 할 때만 락
        - 문제점: 여러 스레드에서 운이 나쁘면 여러 인스턴스를 생성할 수 있다.
    - **LazyHolder** 
        – 내부 클래스를 두고 해당 클래스의 인스턴스를 호출할 때 클래스를 로드하여 초기화 한다. 로딩 시점은 thread-safe하고 성능도 좋다.

### 🎯 싱글턴 패턴 VS static / 결국 객체를 하나만 사용하는 효과는 동일한데 무슨 차이?
- **싱글턴:** 
    - 사용자 요청 시 하나의 인스턴스를 생성해 재사용. 초기화 시점 조절이 가능 (아예 초기화 안 할 수도)
    - 인터페이스 구현 가능 (확장, 오버라이딩 가능)
    - 싱글턴은 OOP 원칙 준수 가능
- **Static:** 	
    - 인스턴스를 만들 수 없고, 생성자도 갖지 않는다. 처음 로드될 때 초기화
	- 인터페이스 구현 불가능
	- Static 메소드는 인스턴스 변수를 사용할 수 없다.
- 싱글턴을 사용하는 경우 - 로깅, 캐싱, DB 커넥션풀, 카메라, 센서 등
- static을 사용하는 경우 - single-instance, global 데이터를 저장하여 사용하는 용도
	
### 🎯 immutable이란?
- 변경되지 않음
- Thread safe – 바뀌지 않는 값은 다중 스레드 상황에서도 예상된 결과를 반환
- 유지보수 관점에서 객체를 넘겨서 사용할 때 값이 변경된다면 문제가 발생할 수 있다.
- 다른 곳에서 사용할 땐 복사해서 넘겨주는 것이 좋다. (방어적 복사) 읽기와 쓰기는 분류해서 사용하는 게 좋다. 

### 🎯 예외의 종류와 차이는?
- **Checked exception**: 컴파일시 발생하는 예외 / 복구 가능 / 보통 Exception을 확장한 클래스
- **Unchecked exception**(runtime exception): 런타임에 발생하는 예외 / 복구 불가능 / API 명세에 기록된 제약을 지키지 못했을 때
- **Error**: 자바 프로그램 밖에서 발생한 예외 / ex. 디스크, 메인보드 고장

### 🎯 언체크 예외를 캐치하는 이유?
- 컴파일은 잘 되지만
- 예외가 발생했을 때 해당 클래스를 호출하는 다른 클래스에서 예외를 처리하도록 구조적 안전장치

### 🎯 예외 처리 방법?
*복구, 회피, 전환*
- **복구** 
    - try-catch문에서 복구할 수 있는 것을 복구한다.
    - ex. 커넥션
- **회피**
    - 내 책임이 아닐 때 
    - ex. 쿼리문을 잘못 적은 것은 메소드를 만든 사람의 문제가 아니라 메소드를 가져다 쓰는 사용자의 잘못 -> 사용한 사람이 처리
- **전환** 
    - 다른 layer에서 이해할 수 있는 예외로 translation
    - ex. SQLException은 사용자들이 이해하지 못하므로 “데이터를 가져오지 못했습니다”라고 표현

### 🎯 (트랜잭션) 특정 예외는 롤백(복구)이 안된다. 어떤 것?
- 체크 예외는 복구를 요구하는 것
- 중복 복구가 되므로 롤백 처리를 하지 않는다.

### 🎯 반복문에서 i++ VS ++i 무엇이 더 빠를까?
- 자바 컴파일러가 자동으로 바꿔준다. (그러므로 똑같다.)
- 바이트코드에서 실행순서의 차이 (++i 가 더 빠르긴 함)

### 🎯 static을 잘못 썼을 때 생기는 문제점?
- 가변적인 변수이면 예상한 결과가 나오지 않을 수 있다.
- 메모리 릭(사용가능한 메모리 부족) 가능성
    > static으로 선언한 부분은 GC가 되지 않는다.

### 🎯 메소드에 synchronized가 걸리면 어느 부분에 락이 걸릴까?
메소드에 들어가는 모든 객체에 락 / 객체 단위로 락

### 🎯 I/O가 일어날 때 스레드에서 일어나는 일?
- Blocking
- 왜 block 할 수밖에 없나?
    - Stream을 이용한 단방향 통신
    - 운영체제 대기 큐에 들어가면서 요청에 대한 system call이 완료된 후에 응답을 보낸다.
> 블로킹과 Sync: https://musma.github.io/2019/04/17/blocking-and-synchronous.html

### 🎯 NIO는 왜 Block 시키지 않을까?
- Channel을 이용한 양방향 통신 – 읽기, 쓰기를 하나의 통로로(buffer 사용)
- 비동기 방식 지원 – 운영체제 대기 큐에 들어가지 않고 실행 여부와 관계없이 바로 응답을 보낸다.
- non-blocking
    - 클라이언트들은 각각의 채널 할당
    - 셀렉터: 순차적으로 핸들러에 동작 실행 
    - 핸들러: IO 작업을 단일 스레드로 처리 가능

### 🎯 System.out.println을 쓰지 말아야 하는 이유?
- 커널 CPU를 많이 점유하기 때문에 성능이 떨어진다.
    - 완전히 출력되거나 저장될 때까지 대기
- Stream I/O & Synchronized 사용 – 오버헤드 발생
- 동기화, IO blocking – 병목 발생
- Logger -> 별도의 스레드로 출력
> https://mygumi.tistory.com/83

### 🎯 로거의 내부 구조는 어떻게 되어있길래 로그 찍는 속도가 빠를까?
> https://lob-dev.tistory.com/entry/Logging-slf4j-Logback-Framework

### 🎯 Auto-Closeable 이란?
- 실수로 자원 반납을 하지 않는 것 방지
- Try-with-resources
    - try에서 선언된 객체들을 try가 종료될 때 자동으로 자원 반납
    - 해당 객체는 AutoCloseable을 구현해야 함 (try 구문이 종료될 때 자동으로 close() 메소드 호출)
    - 보통 finally에서 자원 반납을 하였는데 autoCloseable을 사용하면 명시적으로 호출해 줄 필요 없음
    - But, 객체는 try 구문 안에서만 사용가능

### 🎯 JVM이란?
- Java가 OS에 구애받지 않고 실행할 수 있게 해 줌
- 스택 기반의 가상머신
- 메모리관리, GC 수행
- 구성: 클래스 로더 / 실행 엔진 / 인터프리터 / JIT / 가비지 컬렉터

### 🎯 JIT optimizer / JIT compiler 란?
- “Just in Time”, “동적 변환” 
- 프로그램 실행을 보다 빠르게 함
- 컴퓨터 프로그램 실행 방식:
	1. **인터프리트 방식**: 프로그램을 실행할 때마다 컴파일. 간편하지만 느림
	2. **정적 컴파일 방식**: 실행하기 전 컴파일을 한 번만 수행
- JIT 컴파일러는 위 두가지 방식을 혼합한 것
    - 변환작업은 인터프리터에 의해 지속적으로 수행되지만, 필요한 코드의 정보는 캐시(메모리)에 담아 두었다가 재사용 한다.
- optimizer: 소스코드를 바이트코드로 된 class 파일로 변환 (javac)
- compiler: 런타임시 바이트코드를 CPU로 직접 보낼 수 있는 명령어(시스템코드)로 변환
javac로 컴파일하는 것은 그저 어떤 OS에서도 수행될 수 있는 바이트 코드 파일로 만드는 것.
- 프로그램이 실행되기 위해선 바이트 코드를 컴퓨터가 알아들을 수 있도록 변환해야 한다. 이것을 JIT 컴파일러가 수행한다.

### 🎯 자바 코드 로딩 절차는?
1. java 파일을 컴파일하여 바이트 코드인 class 파일로 변환.
2. class loader가 런타임시에 class 파일을 JVM에 로딩
3. JVM – JIT 컴파일러 …

### 🎯 GC 과정은?
- GC: 동적으로 할당한 메모리(힙) 영역 중 사용하지 않는 객체를 탐지하여 해제하는 기능
- 구조:
    - 힙은 Young 영역과 Old 영역, Permanent 영역으로 나눠 짐
    - Young 영역은 또 Eden과 Survival1,2로 나눠 짐
    - Permanent 영역은 클래스나 메소드 정보 저장
- “Concurrent Mark and Sweep”
    - 가비지 컬렉터가 stack의 모든 변수를 스캔하면서 각각 어떤 객체를 참조하는지 찾아서 마킹
    - Reachable Object가 참조하고 있는 객체도 찾아서 마킹
    - 마킹되지 않은 객체를 Heap에서 제거
- Minor GC: 
    - 새로 만들어진 객체는 Eden 영역에 위치
    - Eden 영역이 차면 살아있는 객체만 survival 영역으로 객체가 복사되고(GC) 다시 eden 영역을 채운다.
    - Survival 영역이 차면 또 다른 survival 영역으로 객체가 복사(GC). 이 과정을 반복 (하나의 survival 영역은 무조건 비어 있어야 한다.)
- Full GC/Major GC 
    - Minor GC를 수행하며 survival 영역의 객체의 age를 주기마다 증가시키고, 일정 값이 되면 old 영역으로 이동한다.
    - Old 영역이 차면 GC 수행

### 🎯 major GC가 일어나면 어떤 끔찍한 일이 벌어질까?
- GC를 수행하기 위해 JVM이 멈춤
- “Stop the world” – 성능 저하

### 🎯 병렬 콜렉터 / 병령 콤팩팅 콜렉터
- 공통점: GC를 수행하는 스레드가 여러 개. 빠르게 GC 처리 가능 (코어 수가 많을 때 유리)
- 차이점: 콤팩팅(객체 삭제 후 한 곳으로 모으는 작업) 수행 여부

### 🎯 CMS GC 와 G1 GC 의 차이?
- **CMS** (old 영역의 GC가 다름)
    - 초기 마킹 단계에서 짧은 대기시간으로 클래스 로더에서 가장 가까운 살아있는 객체만 찾는다.
    - 이후 concurrent 마킹 단계에서 위의 살아있는 객체에서 참조하는 객체를 따라가며 확인(별도의 스레드)
    - “stop the world”시간이 짧다.
    - 콤팩팅을 하지 않는다. / cpu를 많이 사용한다.
- **G1**
    - 바둑판 식으로 객체 할당 (young 영역과 old 영역이 물리적으로 나눠져 있지 않음)
    - GC 정지 시간을 최소화 (concurrent)
    - 큰 메모리, 멀티 프로세서 시스템에서 사용
    - 가장 빠른 GC 방법

### 🎯 JMX란?
- Java Management Extensions
- 자바 모니터링 API
- 실행중인 애플리케이션의 상태 모니터링 하고 설정을 변경할 수 있게 해주는 API
- 성능 테스트
> 'jconsole', 'java mission control', 'java flight recoder', 'jvisualvm'

## Java 심화

### 🎯 클래스끼리 상속을 받으면 어떤 점에서 문제가 발생?
- 클래스 간의 상속은 유지보수성 측면에서 좋을까?
- 상위 클래스에서 변경이 일어나면 하위 클래스에서도 변경 필요
- 변경의 여파가 크다. - 메소드 자기 사용
- 유지보수성이 떨어짐

### 🎯 상속 대신에 composition을 사용하는 이유?
- 컴포지션이란?
- 기존 클래스가 새로운 구성요소(필드)로 쓰인다.
- 변경의 여파를 차단
- 객체를 가져다 쓰는 것

### 🎯 인터페이스는 구현하는 쪽을 생각하며 설계하라는 의미는?
- 의도한 용도에 잘 부합하는지 확인
- 잘못 설계하여 나중에 메소드의 추가가 필요한 경우 자바8 이후 default 메소드가 제공되지만
- 불변식을 해칠 가능성이 있고 기존 구현된 자바 코드에 영향을 줄 수 있다.
- default 메소드의 용도는 기존 메소드의 시그니처를 수정하는 용도가 아니다.

### 🎯 상속을 고려해 설계하고 문서화하라는 의미?
- 상속하는 클래스를 만든 사람은 나다. 
- 개발 중 중요하게 생각해야할 것? 의도한대로 소스코드가 동작해야함
- 상속받아 쓰는 것은 의도하지 않은 것 -> 허술하게 설계한 것

### 🎯 유틸 클래스란?
- 객체를 생성하지 않아도 되는 클래스
- 정적 메소드만 가지고 있고, 상태를 가지지 않는다.

### 🎯 객체 생성을 하지 않아도 되는데 private으로 제한해야 하는 이유?
- 의도하지 않은 사용을 방지하기 위해
- 실수의 여지를 없앤다.
> 코틀린은 아무것도 안 붙이면 상속이 불가능

### 🎯 다 쓴 객체의 참조를 해제하라는 이유?
- 더 이상 사용하지 않는 객체인데 계속 참조를 함으로 GC 적용 대상에서 제외되는 것을 방지

### 🎯 equals는 오버라이딩했는데 hashcode를 오버라이딩 하지 않으면?
- **equals**: 내용이 같은지
- **hashcode**: 같은 객체인지(주소값)
(개발 툴에서 자동으로 재정의 해주는 것 추천)

### 🎯 toString을 항상 재정의 하라는 이유?
- 사람이 읽기 쉬운 형태로 확인할 수 있게 함
- 재정의 해야 하는 부분 - 데이터를 담는 dto 같은 클래스는 값을 찍어서 확인해야 함
- 재정의 하지 말아야 하는 부분 - 값을 가지지 않는 클래스(컨트롤러, 서비스 등)

### 🎯 Enum에서 Ordinal을 쓰지 말아야하는 이유?
- 순서가 바뀔 수 있음
- ordinal: 인덱스를 얻는 메소드
- 비검사 형변환 수행 필요
- 배열은 각 인덱스의 의미를 모르니 출력 결과를 직접 레이블에 달아야 함
- 결국 정수값을 사용하는 것 -> 타입 safe하지 않음 / 만약 Enum의 순서가 바뀐다면 다른 의미를 나타낼 수 있음
- EnumMap 사용

### 🎯 리턴 타입으로 스트림을 쓰지 말아야 하는 이유?
- 스트림은 반복(iteration)을 지원하지 않는다. - foreach로 스트림을 반복할 수 없다.
- Collection 인터페이스는 iterable의 하위 타입이고 stream 메소드도 제공한다. - 반복과 스트림 모두 사용 가능

### 🎯 parallel 스트림을 조심하라는 이유?
- 성능 문제
- 병렬처리: 한가지 작업을 서브 작업으로 나누고, 서브작업들을 분리된 스레드에서 병렬적으로 처리
- 멀티 스레딩
- 자바 공용 스레드풀을 사용하므로
- 비싼 연산, 블로킹- 다른 작업이 늦춰질 수 있다.
- 병렬화를 사용할 땐 성능 테스트 필요
- 결과가 잘못되거나 예상 못한 동작 발생 가능 (안전 실패)
- 메소드가 다른 작업 수행에 종속(연관)된 경우 설계한 동작과 다를 수 있음 / 순차적으로 수행되지 않아서

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: Web

### 🎯 request로 가져올 수 있는 것은?
- 헤더의 값, request의 body
- 요청에 들어가는 모든 데이터

### 🎯 response의 객체를 사용할 때는?

### 🎯 JSP의 주석 종류는?
- `<!-- 주석1 -->` : html 소스보기에서 주석이 소스코드에 보인다.
- `<%-- 주석2 --%>` : 주석이 소스코드에 보이지 않는다.
> 주석을 잘못 써서 클라이언트에게 보이는 경우 보안에 문제가 생길 수 있다.

### 🎯 쿠키란?

### 🎯 세션이란?
- 서버에 있는 클라이언트별 저장 공간
- 서버의 메모리(디스크 X)에 저장
> 쿠키와 세션 - https://sdevstudy.tistory.com/27

### 🎯 세션 구분 방법은?
- hash라고 생각하면 된다.
- *세션id가 자동으로 쿠키에 들어간다. 어떻게?*
- *Response header 어떤 부분을 설정해주면 클라이언트의 쿠키에 자동으로 값이 설정됩니다. 어떤 부분일까요?*
- 세션 id가 생성되는 시점 - 쿠키 id가 요청이 없을 때

### 🎯 커넥션 풀이란?
- ‘병목현상’ / 부하의 일반적인 원인: 커넥션 과정이 느림 
    - TCP 3way handshaking & 4way handshaking
- 커넥션이 느리기 때문에 재사용한다.

### 🎯 스레드 풀이란?
- 이미 생성된 스레드 재사용
- *톰캣의 스레드 풀은 어떤 역할?*

### 🎯 스레드들이 맡게 되는 역할?
- 사용자 요청 처리 - 스레드 풀에서 동작한다고 할 수 있다.

### 🎯 Connection pool과 Thread pool의 연관관계?
*성능 튜닝 관점 - 스레드풀, 커넥션풀 개수를 어떻게 맞춰야할까?*  
- 정의 및 사용
    - **Connection Pool** 
        - IO, 소켓의 재사용. 연결 시간 최소화  
    - **Thread Pool** (Tomcat의 스레드풀은 어떤 역할을 할까?) 
        - 스레드 생성 시 지연 시간, 추가적인 처리과정. 
        - 이전에 생성된 스레드 재사용. 사이클 오버헤드 및 자원낭비 방지"
- 보통 스레드의 수가 커넥션의 수보다 많은 것이 좋다. -> 모든 요청이 DB에 접근하진 않음
- 대기 시간(cpu i/o 처리 중 block)이 길 때 스레드 개수를 늘려서 대기 시간을 줄인다.
- 스레드가 너무 많으면 메모리 낭비 (노는 스레드 발생)
> https://yaaam.tistory.com/entry/%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%92%80Thread-Pool-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%92%80%EC%9D%98-%EC%A0%81%EC%A0%95-%ED%81%AC%EA%B8%B0%EB%8A%94-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%92%80%EC%9D%98-%EC%A0%81%EC%A0%88%ED%95%9C-%EC%82%AC%EC%9D%B4%EC%A6%88%EB%8A%94  
> https://junshock5.tistory.com/147 

### 🎯 커넥션 풀이 10, 스레드 풀이 20개면 어떤 일이 벌어지나? (모든 요청이 DB에 연결된다고 가정)
- 스레드는 놀게 된다. (성능 저하)
- 만약 트랜잭션 REQUIRES_NEW에서 새 트랜잭션이 생긴다면 새로운 커넥션이 추가되어 성능 저하..
(스레드 하나가 두개의 커넥션을 잡고 있다.)

### 🎯 톰캣이 스레드를 많이 띄우는 이유?
*blocking IO가 일어나면 스레드를 많이 띄워야 할까?*
- 스레드는 CPU에게 일을 시킨다.
- 블락이 일어난 스레드에선 다른 일을 할 수 없으므로 다른 스레드를 사용
- 컨텍스트 스위칭 비용이 증가
> 컨텍스트 스위칭을 감수하면서 스레드를 늘리는 이유는? CPU가 놀면서 발생하는 손실이 더 크기 때문

### 🎯 톰캣에서는 어떤 부분에서 IO 상황이 발생할까?
- JDBC를 이용한 DB 연결 시
- 네트워크 IO (요청, 응답)
- 파일 read/write
- 사용자가 파일을 보낼 때

### 🎯 JSP 필터란?
- 필터의 연산 장소: 서버
- 자바 코드는 서버에서 구동. Request 객체 사용. 서블릿 레벨

### 🎯 톰캣 네트워크 트래픽 수신 - 스레드에 전송 - [무슨 일?] - jsp 코드 실행
*톰캣 구조와 실행에 대한 질문.*
- 문자열 파싱, 리퀘스트 객체 생성, 메소드 구분, 헤더 처리 등

### 🎯 주소창에 URL을 입력하고 브라우저에 표시될 때까지의 과정은?
> https://deveric.tistory.com/97

### 🎯 Tomcat에서의 출력은?
- System.out.print()를 쓰면 catalina.out 로그 파일에 작성된다.
- 하지만 어플리케이션 성능을 떨어뜨린다.
- 대신 log4j 사용하라

### 🎯 Web Server VS WAS?
- **정적**(html, 이미지, 동영상 등) / **동적**(회원에 따라 바뀌는 정보)
- WAS 앞에 서버를 둬서 웹 서버에서는 정적인 문서만 처리하도록 하고, WAS는 어플리케이션의 로직만 수행하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.
- 클라이언트와 연결하는 포트가 직접 WAS에 연결이 되어 있다면 설정 파일들이 노출될 수 있기 때문에 WAS 설정 파일을 외부에 노출시키지 않도록 하기 위해서 웹 서버를 앞 단에 배치(방화벽 형태)할 수 있다.
- 요즘엔 정적인 것은 보통 클라우드 서버에서 처리

### 🎯 “Keep Alive”란?
- 연결을 끊지 않음
- 커넥션 유지, 비용 절감
- HTTP는 Connectionless 방식으로 연결을 매번 끊고 새로 생성하는 구조
- 이미 연결되어 있는 TCP를 재사용(hand-shake 과정 생략)

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: Spring

### 🎯 스프링을 사용하는 이유?
- 자바의 객체지향 원칙을 잘 지키면서 개발을 원활하게 도와주는 프레임워크
- *spring 핵심 가치(**IoC/DI, AOP, PSA**)를 예로 든다.*
    - Ioc, DI - 객체들의 강한 결합을 느슨하게 하여 재사용성과 유지보수성을 높인다.
    - 모듈 단위 테스트
    - 유용한 기능을 묶어서 사용하기 편하게

### 🎯 스프링과 스프링부트의 차이점?
*IoC 관점*
- 스프링 IoC에 기본적인 설정 값을 가지고 객체를 자동으로 관리하는 편리함 제공
- 편리한 의존성 관리

### 🎯 스프링에서 IoC란?
- 제어의 역전(Inversion of Control)
- 이전에는 의존 관계의 제어를 개발자가 직접 했지만, 그 제어권이 컨테이너(ApplicationContext)로 넘어갔고 객체(빈)의 모든 생명주기를 싱글턴으로 관리한다.

### 🎯 스프링에서의 싱글턴과 싱글턴 패턴의 차이는?
- 스프링에서는 구현의 자유도가 있다. 
    - 확장(상속) 가능 
        > 자바 스프링도 가능은 하지만 구현이 어려움
- 스프링 싱글턴은 테스트하기 편하다.
- 생명주기의 차이:
    - **자바 싱글턴 클래스는 classloader 단위** (범위: 같은 class loader, war 내부)
        - 클래스 로더마다 한 번만 인스턴스화
        - 클래스 로더를 여러 개 사용할 경우 인스턴스가 하나가 아닐 수 있다. (서로 다른 war 파일은 참조가 불가능)
    - **스프링 싱글턴은 Application context 단위** (범위: 스프링 컨테이너 내부)
        - 스프링 컨테이너는 클래스에 대해서 한 개만의 인스턴스 생성. 
        - 설정 정보에 의해 관리
        - 항상 단일 공유 인스턴스를 리턴하여 thread safe 보장

### 🎯 스프링에서 싱글턴 패턴이 아닌 형식(스코프)을 사용함으로 얻는 이점은?
- 상속 가능
- 싱글턴 패턴 사용은 개발자가 원하는 대로

### 🎯 스프링 DI란?
- 의존성 주입(Dependency Inject)
- 제어의 역전이 일어날 때 스프링 내부에 객체들 간의 관계를 관리할 때 사용하는 기법
- 객체의 생명주기(생성, 주입, 소멸) 관리
- 의존적인 객체를 직접 생성하거나 제어하는 것이 아니라 특정 객체에 필요한 객체를 외부에서 결정해서 연결시킨다.

### 🎯 외부에서 객체를 주입하는 것(DI)의 이점은?
- 객체 간의 결합도를 낮추어 유연한 코드 작성 가능 (유지보수성 향상)
- 다형성 제공 (객체지향 관점에서 설명 필요)

### 🎯 생성자 주입을 하는 것이 좋은 이유?
- 불변성 (생성 시점에 한 번만 호출)
- 순환 참조(비즈니스 로직으로 인한 서로의 메서드를 순환 호출) 컴파일 타임에 방지
- 객체 생성 시점에 필요한 빈을 주입 - 컴파일시에 오류 검사 & 의존 객체의 null 여부 검사
    > - **필드 주입**: DI 프레임 워크가 없으면 동작할 수 없음
    > - **수정자 주입**: 의존관계가 변경될 가능성 존재 

### 🎯 외부에서 get, set 하는 것의 장점?
- 결합력을 낮춤
- 다형성 – 인터페이스 의존 // 테스트 용이성(가짜 객체)

### 🎯 AOP는 객체지향 5원칙 중 어떤 측면?
- 단일 책임 원칙 

### 🎯 AOP로 분리할 수 없는 것은?
*Aspect Oriented Programming*
- 핵심코드라 분리할 수 없는 것 
    > 반대 개념: 부가로직

### 🎯 @RestController 는 어떤 것?
*JSON 형태와 관련 지어 설명*
- Spring MVC Controller에 `@ResponseBody`가 추가된 것
- **JSON 형태**로 객체를 반환
    > `@Controller`는 주로 view를 반환하기 위해 사용

### 🎯 @Service 는 어떤 것?
- 서비스 클래스를 빈으로 등록

### 🎯 @Component 는 어떤 것?

### 🎯 RequestMapping 은 어떤 어노테이션?
- URL당 하나의 컨트롤러에 매핑되던 다른 핸들러 매핑과 달리 **메서드 단위**로 세분화하여 컨트롤러(클래스, 메소드 수준)를 선택

### 🎯 Maven 역할?
- 빌드 도구. 프로젝트의 라이프 사이클 관리(패키징, 배포 등 구체적)

### 🎯 lombok의 역할은?
- "**보일러 플레이트**"(핵심 로직이 아닌 단순 반복되는 코드)를 줄여준다.

### 🎯 스프링에서 어노테이션으로 트랜잭션이 구동되는 방법?
- 어노테이션에 AOP를 적용
- @Transactional 과 AOP  
*(AOP는 깊게 파고들자!)*

### 🎯 트랜잭션 동기화란? (lock과는 별개)
*동기화와 propagation을 분리해서 생각해보자*  
*기존의 트랜잭션이 있다 없다를 어떻게 판단?*
- "스프링에서 트랜잭션과 스레드 로컬의 관계" - 중요!!
- 트랜잭션은 하나의 스레드에서 시작하고 종료. 멀티 스레드환경에서 각 스레드별로 실행되게 설계
- **ThreadLocal** - 스레드 영역에 변수를 설정 / 트랜잭션 매니저는 트랜잭션 컨텍스트 전파하는 데 사용
- 기존의 Connection을 ThreadLocal의 Stack에 보관 후 새로운 Connection을 ThreadLocal에 지정
> https://narusas.github.io/2019/07/17/Spring-Transaction-Note.html

### 🎯 스프링에서의 트랜잭션과 자바 스레드와의 관계?
*'spring transaction threadlocal'*
- 트랜잭션 내에서 스레드가 실행되면 별도의 트랜잭션으로 처리
- 멀티 스레드에서 하나의 트랜잭션은 수행 불가
- threadlocal: 스레드 단위로 로컬 변수를 할당하는 기능을 제공하는 클래스
    - 스레드 로컬 값은 다른 스레드에서 접근 불가
- 트랜잭션은 하나의 스레드에서 시작하고 종료되어야 한다. (Multi-thread 상황에서 트랜잭션은 각 스레드 별로 실행되게 설계해야 한다.)
    - 예를 들어 트랜잭션 전파옵션 REQUIRED_NEW 를 사용한다면 기존의 Connection을 ThreadLocal stack에 넣어 보관해두고 새로운 Connection을 ThreadLocal에 지정함. 
    - 작업 종료 후 commit/rollback 후 stack에서 다시 pop 해와서 기존 트랜잭션을 이어 감.
> https://dzone.com/articles/spring-transaction-management-over-multiple-thread-1

### 🎯 스프링 트랜잭션의 동작원리?
*스레드, 동기화와 연관 지어 설명*

### 🎯 트랜잭션에서 예외발생으로 롤백 시 복구가 되지 않는 것은?
- Checked exception
- 체크 예외는 이미 복구를 요구하므로 중복복구가 됨
> https://interconnection.tistory.com/122

### 🎯 스프링에서 캐시?
- @Cacheable - AOP를 이용해서 빈의 메소드에 캐시 서비스 적용 가능
- 애플리케이션 빈의 메소드에 캐시를 적용하는 이유?
    - 캐시는 기본적으로 성능 향상을 위함.
> https://coding-start.tistory.com/271  
> https://www.youtube.com/watch?v=NxFJ-mJdVNQ

### 🎯 Spring에선 어떤 메커니즘으로 프록시 객체가 생성될까?
*AOP의 핵심은 프록시 패턴*
- **JDK Dynamic Proxy** 
    - 타깃이 하나 이상의 인터페이스를 구현하고 있는 클래스라면 JDK Dynamic Proxy의 방식으로 생성 
- **CGLIB** 
    - 인터페이스를 구현하지 않은 클래스라면 CGLIB의 방식으로 AOP 프록시를 생성
> [토비의 스프링 6장 참고]  
> https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html  
> 위빙 - https://jaehun2841.github.io/2018/07/22/2018-07-22-spring-aop4/#aspectj%EB%9E%80  
> spring proxy 생성 방법 - https://soolow-and-sooteady.tistory.com/1  

### 🎯 JDK Dynamic Proxy 와 CGLIB 의 차이
- 앞서..
    - **리플렉션 기반** - 별도의 API 호출 / 느림
    - **바이트코드 기반** - 별도의 추가적 로직 없이 소스 코드에 박혀 있게 한다. / 빠름
        > 다이나믹 프록시 (내부적으로 프록시를 어떻게 생성하는지까지 알아보기)
    - **java reflection**: 객체를 통해 클래스의 정보를 분석하는 프로그램 기법
        - 원래 자바에서는 동적으로 객체를 생성할 수 없었다. -> 리플렉션 (동적으로 인스턴스 생성)
        - 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩하여 생성자, 멤버 필드, 멤버 메소드 등을 사용할 수 있게 한다.
- **JDK Dynamic Proxy**
    - 인터페이스를 구현하는 클래스만 타겟(인터페이스 강제화)
    - Java reflection을 사용해 target class의 method를 invoke하며, Advise대상이든 아니든 모든 method call마다 reflection invoke를 실시하므로 성능이 떨어진다.
- **CGLIB**
    - 인터페이스 없어도 사용 가능
    - 상속 방식을 이용해서 프록시화 할 메소드를 오버라이딩 (핸들러 - 메소드인터셉터)
    - 바이트코드를 사용해서 target class의 메소드 호출
    - final 클래스나 메소드 사용 불가

### 🎯 Spring profile이란?
- 빈의 구성 설정을 환경별로 나눈다.
- Ex) 로컬 환경용으로 적용

### 🎯 설정 값을 properties로 따로 적는 이유는?
- 유지보수성
- 코드가 바뀔 때마다 모두 컴파일 할 필요가 없다.
- Properties만 따로 컴파일
- Jar 파일의 재사용성, 환경에 따른 유연함
- Properties는 프로젝트에서 완전히 분리할 수 있다.  
*"spring boot inject properties outside jar"*

### 🎯 POJO란?
- 순수 자바 코드 (Plain Old Java Object)
- POJO 철학 – 스프링 종속적이지 않다. 비즈니스 로직에만 집중

### 🎯 스프링부트에서 톰캣에서 스레드풀의 기본 크기는?
200  

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: MySQL

### 🎯 트랜잭션이란?
- 여러 작업을 하나의 로직으로 묶어 줌
    - 예시: 송금
- 어떠한 작업에 대해 데이터 정합성을 맞추기 위해 여러 데이터를 이용한 명령문을 하나의 작업으로 묶어서 처리하는 것
- 하나의 작업으로 묶는다는 의미는 작업이 성공하거나 실패하는 상황을 하나의 명령으로 처리하는 것처럼 처리하는 것

### 🎯 트랜잭션과 Synchronized의 공통점?
- **싱크로나이즈**: 각 스레드 상에서 atomic 한 연산
- **트랜잭션**: 여러 서버에서 DB에 접근할 때 atomic하게 연산하도록 트랜잭션 처리

### 🎯 트랜잭션 ACID 란?
- Automacy
- Consistency
- Isolation
- Durability

### 🎯 트랜잭션 Propagation?
- 다중 트랜잭션 처리 방법
- **트랜잭션 전파타입**: 진행되고 있는 트랜잭션에서 다른 트랜잭션이 호출될 때 어떻게 처리할 지 설정
    - **REQUIRED** - 부모 트랜잭션 합류(만약 부모가 없다면 새로운 트랜잭션)
    - **REQUIRES_NEW** - 무조건 새로운 트랜잭션 생성
    - **MANDATORY** - 부모 트랜잭션 합류(만약 부모가 없다면 예외발생)
    - **NESTED** - 중첩 트랜잭션(해당 트랜잭션 롤백 시 시작 지점까지만 롤백 / 부모 트랜잭션이 커밋되어야 중첩 트랜잭션도 커밋 / 만약 부모가 없다면 새로운 트랜잭션)
    - **NEVER** - 트랜잭션 허용 X (진행중인 부모 트랜잭션이 있으면 예외발생)
    - **SUPPORTS** - 부모 트랜잭션이 있다면 합류 / 없으면 트랜잭션 생성하지 않음
    - **NOT_SUPPORTED** - 부모 트랜잭션이 있다면 보류 / 진행중인 부모가 없으면 트랜잭션 생성 X
> https://deveric.tistory.com/86

### 🎯 DB index를 걸어 주기 좋은 칼럼은?
- Cardinality가 높은 칼럼

### 🎯 MySQL bulk insert가 빠른 이유?
- DB IO 부하 감소, Lock 감소
- 이것을 쓰지 않으면 대용량 트래픽 상황에서 잦은 connection으로 병목 발생 가능  
> https://prosaist0131.tistory.com/entry/insert%EC%99%80-bulk-insert-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C%EC%9A%94

### 🎯 MySQL에서 쿼리를 하나하나 날리는 것 보다 bulk insert 빠른 이유?
- table 구조, 타입, 외래키, 주요키 등 설정 작업을 몇 번 하느냐의 차이
- DB 연결 시간 (배치 작업)

### 🎯 관계형 데이터 베이스란?
*정의를 내려보기(본질적인 것)*  
*데이터간의 관계가 왜 필요한지 고민*
- **정의**: 
    - 서로 관련된 데이터 포인트에 대한 액세스를 저장 및 제공하는 데이터베이스
    - 관계는 테이블간 일대일, 일대다, 다대다 형태로 이루어진다.
- **데이터 간의 관계가 필요한 이유**:
    - 중복된 데이터가 많을 수록 기술적, 경제적 손실
    - 하나를 수정한 경우 중복된 모든 것을 수정해야함
- **장점**:
    - 테이블 구분으로 가시성이 좋다.
    - 데이터의 분류, 정렬, 탐색 속도가 빠름
    - 구조화된 질의 (SQL)로 데이터를 다룰 수 있다.
    - 작업의 완전성(트랜잭션)
    - 데이터 update가 빠름
- **단점**:
    - 스키마 규격에 맞춰서 데이터를 다뤄야 함(유연한 데이터 저장 불가)
    - 데이터 처리에 대한 부하 발생 시 처리가 어려움(복잡한 관계, 부하의 분산이 어려움)

### 🎯 MySQL replication이란?
- 2대 이상의 MySql 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술
 
### 🎯 MySQL replication의 동작 원리?
1. 마스터: 바이너리 로그 (**binlog**)
    > binlog란 무엇일까? - 데이터의 구조나 내용을 변경하는 모든 쿼리 기록
2. 슬레이브: 데이터(바이너리로그)를 받아올 마스터의 정보를 가지고 마스터 서버에 접속해 변경내역 요청 & **릴레이 로그**에 기록
3. 슬레이브의 SQL 스레드가 릴레이 로그에 기록된 변경내역을 재실행 함으로 마스터 서버와 데이터 동기화

### 🎯 innoDB vs MyISAM
- **InnoDB**:
    - 레코드 기반 잠금 제공(높은 동시성 처리 가능)
    - 트랜잭션 지원
    - MVCC(Multi Version Concurrency Control) 
        - 락을 걸지 않고 읽기 작업 수행
    - 외래키 지원
    - 자동 데드락(교착상태: 한정된 자원을 여러 곳에서 사용하려고 할 때) 감지
    - 자동화된 장애 복구
    - 자체적인 버퍼 풀로 특성에 맞게 캐싱, 버퍼링 수행
- **myisam**
    - 운영체제의 캐시에 의존  

*스레드 관련(foreground, background thread)*

### 🎯 MVCC 란?

### 🎯 MVCC를 쓰면 왜 성능이 향상될까?

### 🎯 mysql이 느린 쿼리는 어떻게 잡나?
슬로우 쿼리 로그

### 🎯 트랜잭션 격리 레벨?
> https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation

### 🎯 Phantom Read이란?
- `SELECT ... FOR UPDATE` 쿼리의 경우 다른 트랜잭션에서 수행한 변경작업에 의해 결과가 보였다 안보였다 할 수 있음.
- undo 영역을 lock 할 수 없기 때문에 변경 전 데이터가 아닌 현재 변경된 레코드 표현

### 🎯 InnoDB에서 Phantom Read가 일어나지 않는 이유?
*phantom read 원인부터 설명을 먼저 하면 좋다*  
*'인덱스'*
- next-key lock으로 트랜잭션 중간에 INSERTION 방지
- InnoDB는 인덱스 범위를 lock / gap-lock / next-key lock -> gap 사이의 insertion 방지

### 🎯 Shared lock 과 Exclusive lock 이란?
- **Shared lock**: 읽기 잠금. 
    - 데이터 리소스를 다른 사용자가 동시에 읽을 수 있도록 허용하되 변경은 불가하게 하는 락
    - 리소스에 대한 공유 잠금은 여러 작업에서 소유 가능
- **Exclusive lock**: 쓰기 잠금. 
    - 어떤 트랜잭션에서 데이터를 변경하고자 할 때 해당 트랜잭션이 끝날 때까지 해당 테이블 또는 레코드를 다른 트랜잭션에서 읽고 쓰지 못하도록 락 
    - 배타적 잠금은 하나의 트랜잭션에서만 소유 가능

### 🎯 Shared lock이 Exclusive lock으로 승격되는 경우?
- 트랜잭션 내에서 읽기 작업만 수행되다 데이터의 수정 및 쓰기 작업이 수행될 때  

*트랜잭션이 어떻게 락이 걸리고 접근이 가능한지 생각하는 것 중요!*

### 🎯 인덱스의 자료구조는?
- B-Tree
- B+ tree?
    - 인덱스 구조에서 순차접근을 위한 형태 (특정 키 값이 여러 노드에 공존 가능)
    - 비말단 노드들은 빠른 접근을 위한 인덱스 역할
    - 리프 노드는 연결 리스트 형태로 서로 순차적으로 연결

### 🎯 B-Tree가 좋은 이유는?
- 순서, 빠르게 read
- 순차 IO와 연관시켜서 -> 정렬시킨 후 인접한 곳을 탐색하므로 빠르다.

### 🎯 외래키란?
- 데이터 중복을 방지하기 위해 관련된 속성별로 테이블로 나누어 관리 
- 이때 두 테이블을 서로 연결하는 데 사용되는 키. 부모 테이블의 기본키 또는 고유키를 외래키로 지정 가능
- 데이터 중복 -> 시간적, 공간적 효율이 떨어짐
- FK는 정합성(무결성)을 강제할 때 사용

### 🎯 외래키를 걸지 않는 이유?
- 부하를 줄이기 위해
- 테이블 구조 변경 시 관리 비용이 높음 
    - 부모 테이블의 구조를 변경 시 자식 테이블에 영향이 없는지 확인 필요
- 실행 계획 제어 불가 
    - 쿼리가 언제 끝나는지, 문제되는 이슈가 없는지 파악하는데 어려움
- 성능저하
    - 데이터가 많은 경우 INSERT/UPDATE 할 때 FK가 유효한지 체크
- 확장가능 여부
    - FK는 정합성을 강제할 때 사용 
    - 나중에 쓸 데이터 중 뭐가 필요할지 안 필요한지 판단할 수 없다.
        > 아카이브 / ex. 학생이 졸업해서 지웠는데 DB에 성적까지 지워짐. 성적표 출력하려고 FK 따라가다 오류 발생
- 외래키는 물리적이 아닌 로직으로도 구현 가능
    - 따라서 적절히 사용하는 것이 중요

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  


---

## :label: Data Structure

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: Network

### 🎯 TCP와 UDP의 차이
Connection 

### 🎯 대규모로 TCP 사용시의 문제점은?
- 매번 connect, close 시 handshaking으로 병목 발생
- 해결방법 – 세션, connection pool

### 🎯 내부 IP와 외부 IP
*공인 ip vs 사설 ip*
- 둘로 나눈 이유? 
    - ipv4 주소체계는 표현 수의 한계 존재
- 내부 IP를 사용하는 이유 
    - 외부와 단절된 ip 사용
    - 따로 네트워크 주소체계 구축 필요시 사용

### 🎯 L4, L7 로드 밸런서?
*‘OSI 7계층’*
- 더 빠른 것은 L4
- 요즘엔 기술력의 발전으로 L7도 빠름
> https://m.post.naver.com/viewer/postView.nhn?volumeNo=27046347&memberNo=2521903

### 🎯 L4를 사용했을 때 특정 서버에 몰리는 현상이 발생하는 환경은?
*‘공인 IP & 사설 IP’*
- Virtual IP 단위로만 로드밸런싱 - 하나의 vIP에 연결된 서버의 수가 비슷해야 함

### 🎯 멀티 캐스팅이란?
- 네트워크 관점 - 특정 목적 & 명확한 도착지가 있다.  
*‘broadcasting’ 은?*

### 🎯 CDN이란?
- 물리적 거리 & 데이터 유실
> https://www.akamai.com/kr/ko/cdn/what-is-a-cdn.jsp

### 🎯 포트포워딩이란?
*내 컴퓨터에 WAS를 띄웠을 때 다른 사람이 접속하게 할 수 있을까?*
> 집에서도 사설 서비스 테스트 가능

### 🎯 NAS란?
- 네트워크 주소 변환
- IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서 라우터를 통해 네트워크 트래픽을 주고 받는 기술

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: Operating System

### 🎯 프로세스와 스레드?
- 메모리 공유 가능 여부
> https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html

### 🎯 스레드를 사용하는 이유?
- 성능적인 측면 
    – 일을 많이 시킬 수 있다. 
    - 속도가 빨라진다.
- 스레드가 많아질수록 한정된 CPU로는 부하가 많아진다.
    - **문맥교환(context switching)**: 현재까지의 작업 상태나 다음 작업에 필요한 데이터를 저장하고 읽어오는 작업
        - 컴퓨터에서 동시에 처리할 수 있는 최대 작업 수는 CPU의 코어 수와 동일
        - 만약 CPU 코어 수보다 많은 스레드 실행 시, 각 코어는 정해진 시간동안 여러 작업을 번갈아 수행
        - 스레드가 교체될 때 스레드 간의 문맥교환 발생
        - 문맥교환에 걸리는 시간이 커질수록 멀티 스레드 효율은 저하된다.

### 🎯 I/O가 느린 이유?
- Thread blocking
- 요청을 받는 동안 스레드가 멈춘다. 
    - ex. 파일이 다 써질 때까지 / 네트워크 데이터를 받을 때까지
- 요청받는 동안 스레드가 멈추면 스레드 수를 늘려 CPU의 자원 낭비를 줄일 수 있다. 
- But 과도한 스레드 생성에 주의 (Context switching 시간)

### 🎯 디스크와 메모리의 차이?
*데이터 영속성, 속도, 가격, 메모리 크기*
- **메모리**: 
    - 일시적 데이터 저장(휘발성, 임시저장장치)
    - 디스크보다 접근 속도가 빠름
    - RAM과 캐시로 나뉨
- **디스크**: 
    - 장기간 데이터 저장
    - 비휘발성 메모리

### 🎯 in-memory와 memory의 차이?
**인-메모리 컴퓨팅**: application 운영을 위한 데이터를 디스크가 아닌 메인 메모리에 모두 올려서 서비스를 수행하는 것

### 🎯 디스크에서 어떤 방식으로 데이터를 읽어오는가?
- 기계식
- 디스크, 디스크 암

### 🎯 순차 IO와 랜덤 IO?
- **순차IO**: 디스크에 데이터를 읽고 쓰는 여러 작업을 한 번에 수행
- **랜덤IO**: 디스크에 데이터를 읽고 쓰는 작업이 오면 바로 수행 
    - DB 연결이 많아지므로 작업 부하가 큼  

*디스크 - (Mysql) B-tree와 연관지어서*

### 🎯 HDD vs SSD?
- 기계식 vs 전자식
- SSD는 수명이 정해져 있다.
> HDD vs SSD - https://coderlife.tistory.com/317

### 🎯 스레드 풀이란?

### 🎯 캐싱이란? 어떨 때 사용해야 하는가?
- 속도가 느린 디스크에서 데이터를 연산이 빠른 메모리로 불러오는 것
- 비용이 오래 걸리는 연산 결과를 캐시에 저장하여 똑같은 요청이 왔을 때 처리하는 방법
- 자주 접근되는 데이터를 더 빠른 속도의 메모리상에 가지고 와서 연산을 수행하여 성능을 높인다.
- 캐시와 캐싱:
    - **캐시**: 컴퓨터의 성능을 향상시키기 위해 사용되는 메모리
    - **캐싱**: 캐시 영역으로 데이터를 가져오는 것.
- 캐싱을 사용하면 안되는 경우 - '정합성이 보장되어야 하는 경우'
    > Ex) 5초 정도의 지연시간은 사용자 입장에선 크리티컬하진 않다. - 캐싱 해볼만 하다.
- 값비싼 비용이 들어가는 요청, 데이터베이스 접근, 외부 요청 등에 캐시를 사용하지만 여기서 전제가 있다. 
    - 캐시는 반복적으로 동일한 결과를 주는 작업에만 이용해야 한다.
    - 매번 다른 결과를 돌려줘야 하는 작업에는 캐시를 적용해봐야 오히려 성능이 떨어진다.

### 🎯 CPU에서 캐시를 사용하는 이유?
- 연산 속도 UP
- 메모리로 갔다 오는 시간도 아깝다.
- CPU 코어(고속)와 메모리(상대적으로 느림) 사이에서 속도 차에 따른 병목 현상 완화

### 🎯 캐시 히트율이란 무엇일까? / 이 것에 영향을 끼치는 옵션들은 무엇이 있을까?
- `적중률 = (캐시 히트 횟수) / (전체 참조 횟수)`
- 영향을 주는 것 
    - 캐시 메모리 크기, 캐시 관리 방법, 캐시 만료 시간
- 캐시 관리 방법 
    - ex) **LRU**(Least Recently Used): 가장 최근 사용된 것을 캐시 맨 앞에 배치
- 캐시 메모리 성공여부는 "참조의 지역성" 원리에 달려있다.
- **지역성**: 짧은 시간동안 제한된 주소 공간의 일부만 참조되는 경향
    - **시간적 지역성**: CPU가 한 번 참조한 데이터는 다시 참조할 가능성이 높다.
    - **공간적 지역성**: CPU가 참조한 데이터와 인접한 데이터 역시 참조될 가능성이 높다.
    - **순차적 지역성**: 분기가 발생하지 않는 한 명령어는 메모리에 저장된 순서대로 인출/실행된다.
> https://zion830.tistory.com/46  
> https://wikidocs.net/65523 

### 🎯 로컬 캐싱 VS 글로벌 캐싱
> https://goldfishhead.tistory.com/29 
- 네트워크 비용 차이
- 글로벌 캐시 - 정합성 높다.
    - 정합성이 중요한지 성능이 중요한지..
    - 정합성과 성능은 trade off
        - 그때그때 다르다. 
        > 자세히:  
        > - 새로고침 할 때 내용이 매번 달라진다.  
        > - 서비스 관점에서 페이스북은 새로고침 할 때마다 정보가 바뀌는 것은 문제가 없지만, 뉴스 기사에 대해서는 조작의혹 때문에 굳이 매번 업데이트 될 필요는 없다.
- 로컬 캐시 단점: 서버마다 중복된 캐시 존재 가능
- JVM으로 동작하는 프로그램에서 캐시를 구현 시 비효율적인 측면? 
    - 캐시는 메모리에 오래동안 저장 
    - GC 스캔으로 인한 성능 저하

### 🎯 CPU 코어 갯수보다 스레드 수가 많아지면 어떤 일이 벌어질까?
context switching 이 빈번하게 발생

### 🎯 그래도 스레드 수를 늘려야 하는 이유?
IO를 사용하면 스레드가 멈추고 그 시간에 CPU는 놀고 있고 다른 스레드를 만들어 다른 것 처리

### 🎯 I/O가 일어나면 스레드엔 어떤 일이 일어나나?
Block. 스레드가 놀게 된다.

### 🎯 스레드가 많아서 문제?
스레드 풀

### 🎯 스레드 풀을 사용하더라도 문제 발생
blocking으로 스레드를 많이 띄워서 스레드가 계속 생성 & context switching  
-> (spring) ***spring5 webflux non blocking IO***

### 🎯 디스크 스왑이란?
- RAM 공간이 부족할 때 디스크 영역에서 프로세스의 데이터를 in/out 
- 만약 JVM에서 힙 영역 크기를 램 전체를 사용하게 한다면
- 메모리는 힙 말고도 다른 영역에서 사용하는 메모리가 있는데 메모리가 부족하기 때문에 디스크 스왑이 자주 발생하게 된다.

### 🎯 디스크 스왑과 cpu 사용률?

### 🎯 스레드를 많이 띄우는 이유?
IO

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: DevOps

### 🎯 Scale Up VS Scale Out
*우리 서비스에는 어떤 것이 왜 잘 맞을까?*  
*확장에 한계가 없어야 한다. / 최대한 전면 장애는 막아야 한다.*  
*Mysql은 scale up 만 가능하다.*

### 🎯 Sticky session이란?
*단점 상황도..*
- (단점) 특정 서버에 트래픽이 없을 수 있다.
    - 서버에 문제가 생겼을 때 복구 후
    - 새로운 서버 구축 시
    - 새로운 클라이언트가 요청하지 않는 이상 균일하게 트래픽이 분배되지 않는다.

### 🎯 Session clustering이란?
*단점?*

### 🎯 Session Clustering에서 정합성 문제가 발생하는 이유?

### 🎯 3대 이하의 서버에서 Session Clustering을 추천하는 이유?
- 세션 복제 비용이 적다.
- 네트워크를 타는 것은 비용이 비쌈 - 서버가 늘어날 수록 네트워크 비용 증가
- 세션을 로컬 메모리에서 가져오는 것은 빠르고 성능상 좋다.
- trade off 관계
*'세션 클러스터링 멀티 캐스팅'*

### 🎯 "내 프로젝트"에 MySQL Replication을 적용해야하는 이유?
1. **데이터 백업은 중요**
    - 비즈니스 기록이 날아가면 서비스에 치명적
    - 대부분의 DB를 사용하는 서비스는 백업이 필수적이라 생각
2. **부하 분산 처리**
    - 공연 티케팅 서비스에서 공연 정보를 조회하는 요청에 대해
    - 공연 정보는 거의 변동되지 않고 변동되더라도 크게 문제가 되지 않는 고정 데이터 (완벽한 실시간 동기화 보장이 필요하지 않음)
    - 읽기 요청에 대해 여러 서버로 분산시켜 성능 향상

### 🎯 항상 slave를 실시간으로 동기화 시켜주어야하나?
일관성과 성능은 trade off 관계

### 🎯 트래픽을 서버가 받을 수 있는 한계 끝까지 보낼때 CPU를 100% 다 못쓴다면 어떤 원인?
- IO 부하가 높은 경우
- 스레드가 부족
- 해결: 스레드수를 늘린다.
> https://injae-kim.github.io/dev/2020/07/09/how-to-check-single-server-load-average.html 

### 🎯 메모리 부족?
*'디스크 스왑'과 CPU 사용률의 관계*  
- 문제 원인
    - 특정 프로세스가 극단적으로 메모리 소비
    - 스왑이 발생하면 disk 액세스가 발생하여 느림
- 해결: 메모리 증설, 캐시 서버 도입

### 🎯 스레드를 수백개를 띄우는 이유?
blocking IO - cpu가 놀아서

### 🎯 스레드를 늘렸음에도 cpu사용률이 떨어지는 이유?
- blocking io가 너무 많은 경우
    - blocking으로 서버를 붙잡고 있는 시간이 늘어나면 CPU 사용률이 떨어진다.
    - 해결: non-blocking 방식 또는 비동기 방식으로의 변경
- 사용자 응답 받는데 너무 오래 걸리는 경우
- 외부 api 사용으로 인한 대기
- 데이터베이스 응답이 너무 느릴 때 (DB 서버 성능)
    - 쿼리는 동기식
    - 해결: 쿼리 튜닝 & DB 서버 증설
- 지역적으로 네트워크 상황이 안좋은 경우도 있음
    - 해결: 네트워크에서 보내는 양을 줄이기 위해 클라이언트에게 데이터를 압축해서 보내줌

### 🎯 트래픽을 끝까지 넣었을 때 성능이 완전하지 않은 경우 마지막?
- 커넥션 풀의 크기 조정
- 크기가 작다면 대기하는 요청이 많아진다.

### 🎯 CI 를 해야 하는 이유?
*Continuous Integration*
- 개발자가 개발에 더 집중
- 예를 들어 빌드나 테스트를 다른 존재에게 맡김으로 부담을 덜어낸다.

### 🎯 CD 를 해야 하는 이유?
*Continuous Delivery*
- 배포 자동화를 다른 존재에게 맡김으로 개발에 더 집중
- CD 적용이 안된다면,
    - 배포 과정에 실수가 있을 때 
    - 장애 발생
    - 서비스에 큰 영향
    - 배포에 큰 부담(심리적 부담) 
    - 사용자에게 빠르게 배포, 피드백 반영 시간 느려짐

### 🎯 무중단 배포 방식의 종류는?
"블루/그린 배포 방식"
> https://wonit.tistory.com/330

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  

---

## :label: ETC

### 🎯 Log4j2 vs Logback vs Slf4j
> https://minkwon4.tistory.com/161  
> https://junshock5.tistory.com/124 

### 🎯 Log4j2가 빠른 이유?
- GC 관련 등
    - Garbage Free 
    - ThreadLocal에 저장된 객체 재사용/텍스트를 바이트로 변환할 때 버퍼 재사용 
    - gc 부하가 적다.
> https://logging.apache.org/log4j/2.x/manual/garbagefree.html  
> https://sematext.com/blog/log4j2-tutorial/ 
- 프로젝트에 적용 - 이슈
> https://theuphill.tistory.com/6 

### 🎯 현재 사용하는 Spring boot 버전에서 사용하는 Default Logger는 무엇일까?
spring boot 2.4.2 – logback

### 🎯 RDB와 NoSQL 중에 무엇을 선택할것인가?
> https://itwiki.kr/w/CAP_%EC%9D%B4%EB%A1%A0  
> https://m.blog.naver.com/PostView.nhn?blogId=windfalcon1&logNo=220402574806&proxyReferer=https:%2F%2Fwww.google.com%2F 
- **CAP 이론**: 어떠한 분산 시스템도 일관성(Consistency), 가용성(Availability), 분할내성(생존성, Partition tolerance) 3가지 모두 만족시킬 수 없다.
    - **일관성**: 
        - 모든 노드들은 같은 시간에 동일한 항목에 대하여 같은 내용의 데이터를 사용자에게 보여준다.
    - **가용성**: 
        - 모든 사용자들이 읽기 및 쓰기가 가능해야 하며, 몇몇 노드의 장애 시에도 다른 노드에 영향을 미치면 안된다.
    - **분리 내구성**: 
        - 메시지 전달이 실패하거나 시스템 일부가 망가져도 시스템이 계속 동작할 수 있어야 한다.
- RDB - 일관성 & 가용성
- NoSQL - 일관성 & 분할내성
> https://osy0907.tistory.com/m/95

### 🎯 Cursor paging VS Offset paging
- **오프셋 방식**:
    - 장점: 
        - 원하는 페이지를 명시하여 조회할 수 있다.
    - 단점: 
        - 조회 중 데이터의 추가/삭제가 발생하면 데이터의 누락이 생긴다.
        - 조회 성능이 좋지 않다. 
            - 원하는 위치를 조회하기 위해 이전 레코드를 모두 거쳐 탐색한다.
- **커서 방식**:
    - 장점:
        - 조회 성능이 좋다.
            - 지정된 레코드 위치를 바로 조회한다.
            - 데이터의 누락이 발생하지 않는다.
    - 단점: 
        - 원하는 페이지를 명시하여 조회할 수 없다. (무한 스크롤)
        - 상대적으로 구현이 복잡하다.
> https://bbbicb.tistory.com/40  
> https://wonyong-jang.github.io/database/2020/09/06/DB-Pagination.html

### 🎯 AWS S3를 사용해야 하는 이유?
- AWS S3 (Simple Storage Service)
    - 인터넷 스토리지 서비스(파일 서버)
    - HTTP 프로토콜로 정적 웹처리를 할 수 있는 기능을 가진 클라우드 저장소
- 서버에 미디어 파일을 저장해야하는 경우
    - 1) EC2와 EBS만을 사용해서 저장을 하게되면 용량에 따른 과금도 부담 => 비용
    - 2) 저장소를 구축해서 관리하는 것에도 문제 => 성능
- 한 곳에 모든 미디어 파일을 관리
- 장점:
    - 데이터 센터에 문제가 생긴 경우(디스크 쇼트 / 파일 관리 비용 UP) 백업을 전세계에 걸쳐서 함
    - 자동 데이터 관리(수명 주기 관리)
    - 데이터 전송 시 암호화 처리로 보안 강화
    - 유연한 저장 공간 관리(확장/축소)
    - 추가적으로 데이터 센터를 구축, 관리 할 수 있지만 비용이 많이 발생한다.
    - AWS S3를 사용하면 비용이 획기적으로 줄어든다.

### 🎯 spring5 webflux 란? 
- 비동기-논블로킹 리액티브 개발에 사용 (reactive streams: 논블로킹과 백프레셔를 이용한 비동기 데이터 처리의 표준)
- 적은 수의 스레드로 동시성 처리 (빠르다기 보단 적은 리소스로 많은 트래픽 감당 가능)
- 서비스간 호출이 많은 마이크로서비스 아키텍처에 적합
- 논블로킹 웹 스택 사용 시 적용
> https://hojak99.tistory.com/453 

### 🎯 non-blocking을 사용할 때 blocking을 섞어서 쓰면 안좋은 이유?
*IO와 관련하여..*  
> https://akasai.space/nodejs-3/

### 🎯 R2DBC (JDBC랑 뭐가 다를까?)
*non blocking 과 연관지어서*
- Reactive Relational Database Connectivity
- spring에서 사용되는 JDBC는 항상 blocking 방식으로 제공 
    - 쿼리를 수행하고 결과를 받기까지 blocking으로 스레드 대기 문제가 존재
- blocking과 non blocking의 차이: 
    > https://parkcheolu.tistory.com/33 
- WebFlux를 사용해서 비동기-논블로킹 리액티브 개발할 때 논블로킹 방식을 지원하는 DBC

### 🎯 spring5에서 변화?
*'스레드'*
- **리액티브 프로그래밍 = non-blocking IO + Reactive Stream + Backpressure**
- 함수형 프로그래밍 
    - '함수가 반환 값이나 인자가 될 수 있어서 람다식과 메소드 체이닝으로 결과를 만들어 낼 수 있다.'

### 🎯 테스트를 작성하는 이유?
- 코드 명세서 역할 
    - 코드가 어떻게 동작하는지 시나리오와 입력 값, 에러 종류 등의 스펙 확인 가능
- 정상동작 보장
- 유지보수성 향상

### 🎯 단위 테스트란?
가장 작은 단위의 기능 테스트

### 🎯 단위 테스트의 범위란?
- 가장 작은 단위의 기능 테스트 - “고립”
    - 메소드 단위?
    - 단위테스트에는 무조건 DB 연결이 필요한가?
    - 단위 테스트는 모듈이나 애플리케이션 안에 있는 개별적인 코드 단위가 예상대로 작동하는지 확인하는 반복적인 행위
- **논리 단위 테스트**: 하나의 메소드에 집중한 테스트. mock이나 stub을 이용해 테스트 메소드의 경계 제어
- **통합 단위 테스트**: 컴포넌트 간 연동에 치중한 테스트. ex. DB 사용

### 🎯 단위 테스트에서의 고립?
- 다른(외부) 환경에 영향을 받지 않고 원하는 기능만 테스트
- "동작 하나만 검증"
- why?
    - 외부 환경에서 문제 발생 가능
    - 문제가 안생기면 괜찮?
    - 외부환경에 신경을 덜 씀 / 원하는 로직만 테스트
- mock 프레임워크 활용 (mock 오브젝트를 편리하게 작성하도록 도와줌)

### 🎯 @DisplayName 이란?
*원리?*

### 🎯 테스트 결과가 IDE에 출력되는 원리는?
- Junit 플랫폼에서 실행 엔진 & 구현체
- 테스트 결과 레포트
- IDE에서 테스트 환경에서 자체적인 출력방법이 존재(로그아님) 
    - 테스트 엔진이 실행될 때 레포트를 받아온다.
- 테스트 플러그인

### 🎯 Logger를 써야하는 이유?
- **개발자 관점** - 오류처리 작업용(디버그용)
- **서버&관리자 관점** - client의 개별 실행 정보 확인용

### 🎯 git 이란?
- 분산형 관리 시스템
- 특징: 오프라인 상황에도 로컬 저장소에서 커밋이 가능하다.

### 🎯 git을 사용하는 이유?
“버전 관리 시스템”

### 🎯 버전 관리 시스템이란 무엇일까?
- 수정 내역을 관리
*왜 필요한 것인지 개념 잡아보기*

### 🎯 브랜치의 정의?
- 이슈에 따라 버전을 새로 만드는 것
- ‘커밋 = 버전’ 이라고 볼 수 있다.


### 🎯 업무를 배분받았을 때 가장 먼저 해야할 일?
- 구현 방법 & 어떤 툴?
- 요구사항 분석 why?
    - 어떤 기능을 구현하는 것에 왜 해야 하는지 이유를 먼저 파악
    - 의도를 파악 - 어떤 장점? 본질을 파악 & 기획자의 의도와 벗어나지 않음 & 좋은 의견
    - 단순히 시키는 것만 하는 개발자인가 본질을 파악하는 개발자인가가 중요!!  

*(컨벤션은 보통 이미 정해져 있음)*

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#questions)  
