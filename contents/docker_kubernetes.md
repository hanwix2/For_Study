# Docker/Kubernetes

'***시작하세요! 도커/쿠버네티스***' 기반으로 작성
> https://book.naver.com/bookdb/book_detail.nhn?bid=16850447

## :memo: Contents
- [도커란?](#도커란)

---

## 도커란?

### 도커(Docker)
- 리눅스 컨테이너에 여러 기능을 추가함으로써 애플리케이션을 컨테이너로서 좀 더 쉽게 사용할 수 있게 만들어진 오픈소스 프로젝트
- 도커는 GO 언어로 작성됨
- 가상 머신과는 달리 도커 컨테이너는 성능의 손실이 거의 없음
- 도커라고 하면 일반적으로 도커 엔진(Docker Engine)를 의미
    > **도커 엔진**: 컨테이너를 생성하고 제어 및 관리하는 주체.  
    > *도커 관련 프로젝트: Docker Compose, Private Registry, Docker Hub, Docker for Desktop ...*

<br>

### 가상 머신과 도커 컨테이너

<p align="center">
    <img src="./images/VM and Docker.png" alt="가상 머신과 도커 컨테이너의 구조" width="70%" height="70%"/>
    <br/>
    가상 머신과 도커 컨테이너의 구조
    </p>

- **기존의 가상화 기술 (가상 머신)**
    - 정의:
        - Hypervisor를 이용해 여러 개의 운영체제를 하나의 호스트에서 생성해 사용하는 방식
        - 여러 개의 운영체제는 **가상 머신**이라는 단위로 구별되고 각 운영체제는 게스트 운영체제(Guest OS)라고 함
        - 각 게스트 운영체제는 완전히 독립된 공간과 시스템 자원을 할당받아 사용
        - 대표적인 가상화 툴: VirtualBox, VMware 등
    - 장점:
        - 완벽한 운영체제를 생성 가능
    - 한계:
        - 각종 시스템 자원을 가상화하고 독입된 공간을 생성하는 작업은 하이퍼바이저를 반드시 거치기 때문에 일반 호스트에 비해 **성능의 손실** 발생
        - 가상 머신은 게스트 운영체제를 사용하기 위한 라이브러리, 커널 등을 전부 포함하기 때문에 가상 머신을 배포하기 위한 **이미지의 크기가 큼**
    
- **도커 컨테이너**
    - 가상화된 공간을 생성하기 위해 리눅스 자체 기능인 chroot, namespace, cgroup을 사용함으로써 프로세스 단위의 격리 환경을 만들기 때문에 **성능 손실이 거의 없음**
    - 컨테이너에 필요한 커널은 호스트의 커널을 공유해 사용
    - 컨테이너 안에는 애플리케이션을 구동하는 데 필요한 라이브러리 및 실행 파일만 존재
    - **컨테이너를 이미지로 만들어 배포하는 시간이 빠름**

<br>

### 도커를 시작해야 하는 이유
1. **애플리케이션의 개발과 배포가 편해진다.**
    - **독립된 개발 환경 보장**
        - 도커 컨테이너는 호스트 OS 위에서 실행되는 격리된 공간
        - 컨테이너 자체에 특별한 권한을 주지 않는 한, 컨테이너 내부에서 수많은 SW를 설치하고 설정 파일을 수정해도 호스트 OS에는 영향을 끼치지 않는다.
    - **개발/운영 환경의 통합이 가능**
        - 해당 컨테이너를 '**도커 이미지**' 라는 일종의 패키지로 만들어 운영 서버에 전달 (배포)
        - 서비스를 개발했을 때 사용했던 환경을 다른 서버에서도 컨테이너로서 똑같이 복제
        - 컨테이너 내부에서 사용되는 각종 패키지, 라이브러리 설치 등으로 인한 의존성을 걱정할 필요 없음
    - 도커 이미지는 가상 머신의 이미지와는 달리 커널을 포함하지 않음 ***(이미지의 크기가 작음)***
    - 도커는 이미지 내용을 레이어 단위로 구성, 중복된 레이어 재사용 가능 ***(배포 속도 향상)***

2. **여러 애플리케이션의 독립성과 확장성이 높아진다.**
    - 컨테이너는 수 초 내로 생성, 시작이 가능할 뿐만 아니라 여러 모듈에게 독립된 환경을 동시에 제공할 수 있다. (마이크로서비스 구조)
        - **모놀리스(Monolith) 구조**
            - 여러 모듈이 상호 작용하는 로직을 하나의 프로그램 내에서 구동시키는 방식
            - 소규모 서비스에서 사용
            - 서비스의 기능이 복잡하고 거대해질수록 소프트웨어 자체의 확장성과 유연성이 줄어듦
        - **마이크로서비스(Microservices) 구조**
            - 여러 모듈을 독립된 형태로 구성
            - 언어에 종속되지 않고 변화에 빠르게 대응 가능. 
            - 각 모듈의 관리가 용이
    - 예시:
        - 웹 서비스는 데이터베이스 컨테이너와 웹 서버 컨테이너로 분리할 수 있고
        - 웹 서비스에 부하가 발생할 시 마이크로서비스 구조의 웹 서버 컨테이너만을 동적으로 늘려서 부하를 분산할 수 있다.
        - 또한 웹 서버와 데이터베이스의 이미지 버전을 독립적으로 관리하기 때문에 유지 보수도 용이하다.
        - 컨테이너 기반의 마이크로서비스는 개발자가 그 구조를 직접 구현하기보다 도커 스웜 모드, 쿠버네티스 등의 컨테이너 오케스트레이션 플랫폼을 통해 사용하는 것이 일반적
3. **프로젝트 자체의 성숙도나 확장성, 편의성 향상**

<br>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#dockerkubernetes)  
> https://dydtjr1128.gitbook.io/understanding-docker/1.start-docker/1-starting-docker  

<br>
