# 초보를 위한 젠킨스2 활용 가이드 2e

### :paperclip: Contents
- [1. 지속적 통합의 개념](#1장-지속적-통합의-개념)

---

**애자일 방법론**  
    잦은 변경에 빠르게 대응할 수 있는 소프트웨어 배포 솔루션  
    지속적 통합(CI, Continuous Integration) & 지속적 배포(CD, Continuous Delivery)

<br>

## 1장 지속적 통합의 개념

### 소프트웨어 개발 주기
- 소프트웨어 개발의 계획, 개발, 테스트, 배포 단계를 총칭  
(요구사항 분석 – 설계 – 구현 – 테스트 – 진화 - )

<br>

### 폭포수 방법론
- 정의: 명확하게 정의된 절차가 **한 방향으로 진행**되는 개발 방식  
(요구사항 분석 – 시스템 설계 – 구현 – 테스트 – 배포 – 유지보수 - )

- 단점:	
    - 새로운 요구사항이 자주 발생하는 경우 적합하지 않다.
	- 전체 개발이 끝난 후 통합이 이루어져 통합 이슈가 가장 마지막 단계에서 발견
	- 역추적이 불가능
	- 각 단계에서 진행 현황을 알기 어렵다.
	- 불확실성이 크다.

- 장점:	
    - 요구사항이 문서로 잘 정리되고 변하지 않는다.
	- 변동 가능성 낮음

<br>

### 애자일 방법론
- 정의: 빠르고 유연하며 조금씩 발전되는 소프트웨어 개발을 통해 목표를 계속 수정해나감
- 애자일 원칙:	
    1. 고객을 만족시키기 위해 소프트웨어를 빠르고 지속적으로 배포
    2. 새로운 요구사항은 개발 후기에도 기꺼이 받아들임
    3. 동작 가능한 소프트웨어를 몇 달 주기가 아닌 몇 주 주기로 배포
    4. 업무 담당자와 개발자 간의 긴밀한 소통을 지향
    5. 믿을 수 있는 동기부여된 개인들로 구성된 팀이 소프트웨어를 개발
    6. 직접 만나 얼굴을 보며 이야기하는 것이 최선의 의사소통이다.
    7. 동작하는 소프트웨어가 가장 중요한 진척의 척도
    8. 일정한 속도를 유지함으로써 지속 가능한 개발을 추구
    9. 좋은 기술과 설계를 향해 지속적으로 관심
    10. 단순함(하지 않는 일을 늘리는 기법)을 중요시
    11. SOT(Self Organized Team) 추구
    12. 새로운 환경에 지속적으로 적응

- 동작 방식:
	- 이터레이션(계획 세우기, 요구사항 분석, 설계, 코딩, 단위 테스트, 사용자 인수 테스트) 반복
	- 프로젝트의 범위를 최소한의 시간만 사용 (프로젝트는 기능으로 구분)
	- 목표: 하나의 이터레이션에서 기능의 개발, 테스트, 릴리즈 완료
    - 이터레이션이 마무리 될 때 새 기능의 데모 진행. 데모에서 만족하지 못하면 백로그(backlog)로 들어가 이후의 이터레이션에서 구현
	- 하나의 이터레이션에서 하나 이상의 기능을 동시에 구현하고 테스트하는 것도 가능

- 장점:
	- **기능의 빠른 구현과 데모**: 프로젝트는 기능으로 구분
	- **적은 리소스 소요**: 별도의 개발, 테스트 팀 구분 없이 각각의 구성원은 모든 역할 수행
	- **팀워크 향상과 상호 교육**: 여러 역할 바꿔가며 진행, 경험 공유
	- **요구사항이 자주 변경되는 프로젝트에 적합**
	- **최소한의 문서**: 전체 기능에 관한 문서만 존재. 문서 대신 동작하는 소프트웨어 전달을 목표
	- **계획이 없거나 최소한의 계획**: 기능이 하나씩 구현되기 때문에 방대한 계획은 존재하지 않음
	- **동시 개발**

<br>

### 스크럼 프레임워크
- 정의:
    - 애자일 방법론에 기반을 둔 프레임워크
    - 단순 절차가 아닌 정해진 역할과 임무, 팀으로 이루어진 프레임워크
    - 직면한 문제를 개발 팀이 가장 잘 안다는 전제를 기반
    - 스크럼 팀은 SOT이기에 팀 리더는 존재하지 않음

- 주요 용어:
	- **Sprint**: 유용하고 릴리즈 가능한 결과를 생산하는 데 할당된 기간
	- **Product Backlog**: 개발할 소프트웨어에 필요한 모든 기능의 집합. 언제든 추가, 수정, 삭제 가능
	- **Sprint Backlog**: 스프린트에서 진행하기로 결정된 기능의 집합
	- **Increment**: 프로덕트 백로그 중 이번 포함 이전 모든 스프린트에서 완료된 기능
	- **개발 팀**: 스프린트 마지막 릴리즈 가능한 인크리먼트를 만드는 역할
	- **프로덕트 오너**: 스크럼 팀과 그 외 사람들의 중재자. 스크럼과 관련된 모든 의사소통 담당
	- **스크럼 마스터**: 스크럼을 이해시키고 진행. 역할 및 올바른 수행 방법 주지

- 동작 방식:
	- **스프린트 계획**: 스프린트 주기에 포함시킬 기능 결정
		> - 고려사항:
		>	- 작업될 기능 목록
		>	- 이전 스프린트 팀의 작업 실적
		>	- 개발 팀의 예상 능력
	- **스프린트 주기**: 기능 구현
	- **일간 스크럼 회의**: 전날 달성한 작업 & 오늘 작업할 내용 논의. 매일 진행
	- **스프린트 진척 관리**: 일간 스크럼에서 스프린트의 진척 관리. 스프린트 목표 달성 가능성 예측
	- **스프린트 리뷰**: 작업이 끝난 기능의 데모 진행. 프로적트 오너는 프로덕트 백로그 갱신
	- **스프린트 회고**: 스프린트 진행 중 잘된 점과 개선 점 논의. 다음 스프린트에 적용

<br>

### 지속적 통합 (CI, Continuous Integration)
- 정의: 
    - 개발자들이 빠른 주기로 작업한 내용을 통합 브랜치에 통합하고 빌드하는 개발 방식
    - **통합 과정에서 발생하는 이슈를 가능한 빨리 발견하기 위함**
        - 코드가 잘못 반영되거나 수동으로 빌드할 때 실수를 하면 빌드 실패
        - 개인 개발 환경을 통합 환경에 맞게 주기적으로 리베이스하지 않으면 통합 이슈 발생
        - 단위 테스트 케이스나 통합 테스트케이스를 통과하지 못하면 테스트 이슈 발생
    - 이슈가 발생하면 개발자는 코드를 수정해 문제를 해결

- CI를 이용한 애자일
    - 기능 개발 시의 코드 수정 과정을 CI 환경에서 젠킨스 같은 도구를 이용해 모든 과정을 빠르게 에러 없이 진행 가능
        > *코드 반영, 버전 관리 시스템에서 변경사항 가져오기, 빌드, 단위 테스트 진행, 통합, 통합된 코드 빌드, 묶어서 배포*
    - 알람을 추가하면 더욱 빠르게 대응 가능

<br>

### CI의 구성 요소
- **버전 관리 시스템**

- **브랜칭 전략**

- **CI 도구**
    - 지휘자 역할
        > CI 시스템의 중심에서 *버전 관리 시스템, 빌드 도구, 바이너리 관리 도구, 테스트 및 프로덕션 환경, 소스코드 분석 도구 및 자동화 테스트 도구 등* 을 연결
    - 대표적 CI 도구 - 젠킨스
    - 스크립트 언어를 이용해 다양한 소작업 수행
        - 점차 젠킨스 플러그인이 스크립트를 대체
    - Pipeline을 생성하는 방법 제공
        - Pipeline: 연속된 작업의 흐름. CI, 소작업을 관리하거나 배포를 관장

- **빌드 자동화**
    - 코드를 컴파일하고 실행 파일을 만들어내는 여러 단계를 (Ant나 Maven 같은 빌드 도구로) 자동화
    - 많은 시간 절약 가능
    - 빌드가 자주 발생하고 빠르게 수행되면 에러(*빌드 에러, 컴파일 에러, 통합 에러*)를 발견할 확률이 높아지고 발견되는 시점도 빨라진다.

- **코드 커버리지**
    - 테스트 케이스가 커버하는 코드의 양을 백분율로 나타낸 값
    - 커버리지 리포트 지표:
        - 함수(Function) - 테스트가 수행된 함수의 수
        - 명령문(Statement) - 실제 수행된 명령문 수
        - 브랜치(Branches) - 수행된 브랜치 수
        - 조건(Condition) - true/false 값이 모드 테스트된 조건문 수
        - 라인(Line) - 테스트된 라인 수
    - 코드 커버리지 도구
        - Java - Atlassian Clover, Cobertura, JaCoCo

- **코드 정적 분석**(화이트박스 테스트)
    - 코드의 구조적 품질을 측정하는 소프트웨어로 코드가 얼마나 견고하고 지속 가능한지 알려줌
        - 내부적인 구조(반복적으로 사용되는 코드, 주석 처리된 라인 수, 코드의 복잡성 등) 평가
    - 실제로 프로그램을 수행하지 않고 실행
    - 기능적인 부분 분석(동적 테스트)은 제외
    - 낮은 품질의 코드가 merge 되는 것 예방

- **자동화된 테스트**
    - 테스트를 자동화 하면 소프트웨어 배포에 걸리는 시간 대폭 단축 가능
        - 테스트는 오랜 시간이 소요되는 반복적인 수작업
    - 고려사항:
        - 중요하고 구현하기 쉬운 테스트 케이스를 먼저 자동화
        - 그다음으로 기능 중 여러 플랫폼(또는 다양한 설정)에서 테스트되는 테스트 케이스 자동화
    - 소프트웨어 검증시 거치는 테스트(사전 프로덕션 환경 - 테스트 우선순위 결정)
        - SIT(System Integration Test): 통합된 코드가 기능적으로 잘 동작하는지 검증
        - UAT(User Acceptance Test)
        - PT(Performance Test)
    - 모든 테스트의 자동화가 불가능할 수 있다.
        - 중요한 것은 가능한 많은 부분을 자동화하는 것
        - 하나의 환경에 빌드된 결과를 배포하고 기본적인 테스트를 자동으로 수행 후 오래걸리는 나머지 테스트는 수동으로 실행하는 경우도 존재
    
- **바이너리 관리 도구**
    - 바이너리 파일의 버전 관리 시스템
        - 소스코드는 CI를 통해 주기적으로 빌드되어 바이너리 파일로 만들어져 저장됨
        - 결과물이 중앙 서버에 저장돼 필요할 때마다 쉽게 접근 가능
        - 누가, 언제, 어떤 바이너리를 만들었는지 기록
        - 릴리즈를 쉽게 관리할 수 있게 스테이징 환경 제공, CI 절차 속도 향상에 도움
        - 관리 대상:
            - 빌드된 바이너리
            - .rar, .war, .exe, .msi 등의 파일
            - 빌드에 필요한 서드파티 바이너리 파일(ex. 플러그인을 매번 다운로드하지 않고 저장)
        - 빌드가 수행되고 필요한 검증이 진행된 후, 바이너리 파일은 바이너리 관리 도구로 복사.
            - 수동으로 바이너리를 골라 배포, 테스트 가능
            - 테스트가 자동화되어 있다면 자동으로 적합한 테스트 환경에 배포

- **패키징 자동화**
    - 패키징: 빌드 이후 여러 종류의 결과물을 하나로 묶는 과정
    - 이 과정도 CI 도구를 이용해 자동화하면 많은 시간 단축 가능

<br>

### CI 사용의 장점

- **복잡하고 어려운 통합으로부터 해방**
- **메트릭**: 프로젝트의 진행 방향 및 속도 확인
- **이슈의 조기 발견**: 모든 머지 이슈나 통합 이슈 발견 및 빌드 실패 시 알람을 통해 즉각 알림
- **빠른 개발**: 빌드, 패키징, 테스트, 소스코드 통합, 배포 자동화로 개발에 집중 가능

<br/>

> :house: [home](https://github.com/hanwix2/For_Study) :top: [top](#초보를-위한-젠킨스2-활용-가이드-2e)  
